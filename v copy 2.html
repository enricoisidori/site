<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Visualizer – Text Nodes</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="preconnect" href="https://unpkg.com" crossorigin />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <link rel="icon" type="image/png" href="./asset/threadscape/icon.png" />
    <style>
      :root {
        --bg: #0e0e0e;
        --panel: #151515;
        --panel-soft: #161616;
        --ink: #ffffff;
        --muted: #bdbdbd;
        --line: #2a2a2a;
        --btn-hover: rgba(255, 255, 255, 0.08);
        --btn-active: rgba(255, 255, 255, 0.12);
        --field: #1e1e1e;
        --field-hover: #222222;
        --field-focus-ring: rgba(255, 255, 255, 0.18);
      }
      html,
      body,
      #scene {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font: 14px/1.4 system-ui;
      }
      .toolbar {
        position: fixed;
        top: 8px;
        left: 8px;
        display: flex;
        gap: 6px;
        z-index: 10;
      }
      .toolbar button,
      .toolbar label,
      .toolbar select {
        appearance: none;
        -webkit-appearance: none;
        background: transparent;
        border: 1px solid var(--line);
        color: var(--ink);
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      .toolbar button:hover,
      .toolbar label:hover,
      .toolbar select:hover {
        background: var(--btn-hover);
      }
      .toolbar button:active {
        background: var(--btn-active);
        transform: translateY(0.5px);
      }
      .material-symbols-outlined {
        font-family: "Material Symbols Outlined", "Material Icons Outlined",
          "Material Icons", sans-serif;
        font-variation-settings: "FILL" 0, "wght" 400, "GRAD" 0, "opsz" 24;
        font-feature-settings: "liga";
        -webkit-font-feature-settings: "liga";
        -moz-font-feature-settings: "liga";
        font-size: 18px;
        line-height: 1;
        vertical-align: middle;
        display: inline-block;
        user-select: none;
      }
      .toolbar .spacer {
        width: 8px;
      }
      .panel {
        position: fixed;
        left: 8px;
        top: 8px;
        background: var(--panel-soft);
        border: 1px solid rgba(255, 255, 255, 0.06);
        padding: 8px;
        border-radius: 8px;
        max-width: 360px;
        backdrop-filter: blur(2px);
      }
      .panel h3 {
        margin: 0 0 6px 0;
        font-size: 13px;
        color: #bbb;
      }
      .muted {
        color: #aaa;
        font-size: 12px;
      }
      .tooltip {
        position: fixed;
        pointer-events: none;
        background: #111;
        border: 1px solid #333;
        color: #eee;
        padding: 6px 8px;
        border-radius: 8px;
        font-size: 12px;
        max-width: 420px;
        display: none;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.45);
      }
      /* Editor laterale */
      .edit-panel {
        position: fixed;
        top: 8px;
        right: 8px;
        width: 360px;
        max-height: calc(100% - 16px);
        overflow: auto;
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        padding: 10px;
        display: none;
        backdrop-filter: blur(2px);
      }
      .edit-panel h3 {
        margin: 0 0 8px 0;
        font-size: 13px;
        color: #bbb;
      }
      .edit-panel label {
        display: block;
        font-size: 12px;
        color: #ddd;
        margin: 10px 0 4px 0;
      }
      .edit-panel input[type="text"],
      .edit-panel textarea {
        width: 100%;
        background: #0f0f0f;
        color: #eee;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 8px 10px;
        font: inherit;
      }
      .edit-panel textarea {
        min-height: 220px;
        resize: vertical;
      }
      .edit-panel {
        overflow: auto;
        overflow-wrap: anywhere;
      }
      .file-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-size: 12px;
        padding: 6px 0;
        border-bottom: 1px solid #333;
      }
      .file-left {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }
      .thumb {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 1px solid #333;
        object-fit: cover;
        display: block;
      }
      .file-row .name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 220px;
      }
      .file-row .remove {
        cursor: pointer;
        text-decoration: underline;
      }
      .file-row .remove:hover {
        color: #fff;
      }
      .status {
        position: fixed;
        left: 8px;
        bottom: 8px;
        color: var(--muted);
        font-size: 12px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.06);
        padding: 6px 8px;
        border-radius: 8px;
      }
    </style>
    <!-- Three prima di TUTTO -->
    <script defer src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <!-- 3d-force-graph -->
    <script defer src="https://unpkg.com/3d-force-graph"></script>
    <!-- three-spritetext, ORA dopo THREE -->
    <script defer src="https://unpkg.com/three-spritetext"></script>
    <script>
      // Lightweight perf defaults: lazy images/iframes, metadata-only videos
      (function(){
        const setAttrs = (el)=>{
          if(el.tagName==='IMG'){
            if(!el.hasAttribute('loading')) el.setAttribute('loading','lazy');
            if(!el.hasAttribute('decoding')) el.setAttribute('decoding','async');
            el.fetchPriority = el.fetchPriority || 'low';
          } else if(el.tagName==='IFRAME'){
            if(!el.hasAttribute('loading')) el.setAttribute('loading','lazy');
          } else if(el.tagName==='VIDEO'){
            if(!el.hasAttribute('preload')) el.setAttribute('preload','metadata');
            el.playsInline = true;
          }
        };
        if(document.readyState!=='loading'){
          document.querySelectorAll('img,iframe,video').forEach(setAttrs);
        } else {
          document.addEventListener('DOMContentLoaded',()=>{
            document.querySelectorAll('img,iframe,video').forEach(setAttrs);
          });
        }
        const obs = new MutationObserver((muts)=>{
          for(const m of muts){
            m.addedNodes && m.addedNodes.forEach(n=>{
              if(!(n instanceof Element)) return;
              if(['IMG','IFRAME','VIDEO'].includes(n.tagName)) setAttrs(n);
              n.querySelectorAll && n.querySelectorAll('img,iframe,video').forEach(setAttrs);
            });
          }
        });
        obs.observe(document.documentElement,{subtree:true,childList:true});
      })();
    </script>
    <script>
      // Fail-safe: se per CDN o cache SpriteText fosse namespaced, prendilo da window
      const SpriteText =
        window.SpriteText || window["three-spritetext"] || null;
      if (!SpriteText) {
        console.warn(
          "SpriteText non disponibile; userò le label standard come fallback."
        );
      }
    </script>
  </head>
  <body>
    <div id="scene"></div>

    <div class="toolbar">
      <button id="btnOpenFolder" title="Apri cartella" data-tip="Apri cartella">
        <span class="material-symbols-outlined">folder_open</span>
      </button>
      <button id="btnSave" title="Salva" data-tip="Salva">
        <span class="material-symbols-outlined">save</span>
      </button>
      <button id="btnUndo" title="Undo" data-tip="Undo (⌘/Ctrl+Z)">
        <span class="material-symbols-outlined">undo</span>
      </button>
      <button id="btnRedo" title="Redo" data-tip="Redo (⇧⌘/Ctrl+Z)">
        <span class="material-symbols-outlined">redo</span>
      </button>
      <button id="btnConnect" title="Collega (C)" data-tip="Collega (C)">
        <span class="material-symbols-outlined">link</span>
      </button>
      <button id="btnNewNode" title="Nuovo nodo" data-tip="Nuovo nodo">
        <span class="material-symbols-outlined">add_circle</span>
      </button>
      <button id="btnSpawn" title="Nuovo collegato" data-tip="Nuovo collegato">
        <span class="material-symbols-outlined">call_split</span>
      </button>
      <button id="btnDelete" title="Elimina" data-tip="Elimina">
        <span class="material-symbols-outlined">delete</span>
      </button>
      <span class="spacer"></span>
      <button id="btnFit" data-tip="Fit">
        <span class="material-symbols-outlined">fit_screen</span>
      </button>
      <button id="btnToggleSize" data-tip="Dimensione testo">
        <span class="material-symbols-outlined">format_size</span>
      </button>
      <select id="colorBy" title="Colora per…" data-tip="Colori per…">
        <option value="none" selected>Colori: Nessuno</option>
        <option value="area">Colori: per Area</option>
        <option value="cluster">Colori: per Cluster</option>
      </select>
      <label
        style="display: inline-flex; align-items: center; gap: 6px"
        data-tip="Selezione camera (POV)"
      >
        <input id="chkPOV" type="checkbox" style="accent-color: #888" />
        POV
      </label>
      <label
        style="display: inline-flex; align-items: center; gap: 6px"
        data-tip="Toggle 3D/2D (3D di default)"
      >
        <input id="chk2D" type="checkbox" style="accent-color: #888" />
        2D
      </label>
    </div>

    <div id="tooltip" class="tooltip"></div>
    <div id="status" class="status" style="display: none"></div>

    <aside id="editor" class="edit-panel">
      <h3>Proprietà nodo</h3>
      <div id="selInfo" class="muted"></div>
      <label for="fTitle">Titolo</label>
      <input id="fTitle" type="text" placeholder="Titolo" />
      <label for="fDate">Data</label>
      <input id="fDate" type="date" />
      <label for="fAreas">Areas (separate da virgola)</label>
      <input id="fAreas" type="text" placeholder="Area1, Area2" />
      <label for="fTags">Tags (separati da virgola)</label>
      <input id="fTags" type="text" placeholder="Tag1, Tag2" />
      <label for="fDesc">Descrizione</label>
      <textarea id="fDesc" placeholder="Descrizione"></textarea>
      <div style="margin-top: 10px">
        <button id="btnAddFiles">Aggiungi file…</button>
        <input id="fFiles" type="file" multiple style="display: none" />
      </div>
      <div id="filesList" style="margin-top: 6px"></div>
    </aside>

    <script>
      const el = document.getElementById("scene");
      let selectedEdge = null; // edge selezionato (s,t)
      // Modalità vista: 3D di default
      let is2D = false;
      const TWO_D_Z = 400; // distanza camera z in modalità 2D
      const Graph = ForceGraph3D()(el)
        .backgroundColor("#0c0c0c")
        .nodeRelSize(1) // irrilevante: non usiamo le palline
        .nodeLabel(() => "") // niente balloon label, usiamo sprite+tooltip
        .linkOpacity(0.45)
        .linkWidth((l) => (isEdgeSelected(l) ? 3 : l.dashed ? 0.6 : 1.4))
        .linkColor((l) =>
          isEdgeSelected(l)
            ? "rgba(255,255,255,0.95)"
            : l.dashed
            ? "rgba(200,200,200,0.35)"
            : "rgba(220,220,220,0.65)"
        )
        .nodeColor(() => "#ffffff")
        .linkHoverPrecision(4)
        .enableNodeDrag(true)
        .onNodeHover((node) => {
          // tooltip disattivato: si usa il pannello laterale su click
        })
        .onNodeClick((node, event) => {
          if (!node) return;
          if (event && event.shiftKey) toggleSelection(node.id);
          else selectOnly(node.id);
          // click sul nodo cancella selezione edge
          selectedEdge = null;
          ensureLinkStyleRefresh();
          if (camOnSelect) {
            // Camera verso il nodo; 3D default, 2D mantiene z fisso
            const distance = 120;
            const nx = node.x || 0,
              ny = node.y || 0,
              nz = node.z || 0;
            if (is2D) {
              Graph.cameraPosition(
                { x: nx, y: ny, z: TWO_D_Z },
                { x: nx, y: ny, z: 0 },
                700
              );
            } else {
              const len = Math.max(1, Math.hypot(nx, ny, nz));
              const ratio = 1 + distance / len;
              Graph.cameraPosition(
                { x: nx * ratio, y: ny * ratio, z: nz * ratio },
                { x: nx, y: ny, z: nz },
                700
              );
            }
          }
          lastPinned = node;
        })
        .onLinkClick((link) => {
          if (!link) return;
          const ids = linkIds(link);
          selectedEdge = ids;
          // clear node selection
          selectOnly(null);
          ensureLinkStyleRefresh();
        })
        .onBackgroundClick(() => {
          selectOnly(null);
          selectedEdge = null;
          ensureLinkStyleRefresh();
        });

      let lastPinned = null;
      let textScale = 1.0; // scala globale del testo
      let selectedIds = new Set(); // selezione multipla
      let currentData = { nodes: [], links: [] }; // dati correnti
      const history = { undo: [], redo: [], limit: 50 };

      // —— Helper immagini + cache texture ——
      // Usa l’istanza di THREE disponibile (quella globale esposta anche da 3d-force-graph)
      const THREE = window.THREE;
      // Base per i path relativi (se l'HTML e la cartella "assets/" sono accanto, lascia "./")
      const ASSET_BASE = "./";
      const DISCIPLINE_JSON_PATH = "./asset/discipline-clusters.json";
      const DISC_FLOOR_Z = -80;
      const DISC_INNER_RADIUS = 70;
      const DISC_OUTER_RADIUS = 320;

      let disciplineLayout = null;
      let disciplineFloor = null;

      // Risolvi una URL immagine a partire dal campo files.path / dataUrl / url
      function resolveImageURL(raw) {
        if (!raw) return null;
        // data URL, blob URL o http(s)
        if (/^data:|^blob:|^https?:\/\//i.test(raw)) return raw;
        // path relativo (es. "assets/xxx.jpg")
        return ASSET_BASE + String(raw).replace(/^\.?\//, "");
      }

      // Trova la prima immagine nel nodo Threadscape (data.files)
      function pickNodeImageFromFiles(files) {
        if (!Array.isArray(files)) return null;
        for (const f of files) {
          if (f && f.isImage) {
            // priorità al path (salvato da “Save to folder”), poi dataUrl/url
            const candidate = f.path || f.dataUrl || f.url;
            const url = resolveImageURL(candidate);
            if (url) return url;
          }
        }
        return null;
      }

      // Raccogli tutte le immagini disponibili per un nodo (files + fallback image)
      function imageUrlsForNode(node) {
        const out = [];
        const files = Array.isArray(node.files) ? node.files : [];
        for (const f of files) {
          if (f && f.isImage) {
            const candidate = f.url || f.path || f.dataUrl;
            const u = resolveImageURL(candidate);
            if (u) out.push(u);
          }
        }
        if (!out.length) {
          const single = resolveImageURL(node.image || node.img);
          if (single) out.push(single);
        }
        return out;
      }

      // Texture loader con cache
      const __texCache = new Map();
      const texLoader = new THREE.TextureLoader();
      function loadTextureCached(url, onOk, onErr) {
        if (!url) return onErr && onErr();
        if (__texCache.has(url)) return onOk(__texCache.get(url));
        texLoader.load(
          url,
          (tex) => {
            __texCache.set(url, tex);
            onOk(tex);
          },
          undefined,
          (e) => {
            onErr && onErr(e);
          }
        );
      }

      // === Discipline clusters layout / floor ===
      initDisciplineLayout();

      async function initDisciplineLayout() {
        if (typeof fetch !== "function") return;
        try {
          const res = await fetch(DISCIPLINE_JSON_PATH, {
            cache: "no-cache",
          });
          if (!res.ok) throw new Error(res.statusText || "HTTP error");
          const payload = await res.json();
          disciplineLayout = prepareDisciplineLayout(payload);
          buildDisciplineFloor();
          applyDisciplineLayout();
        } catch (err) {
          console.warn("Impossibile caricare discipline-clusters.json", err);
        }
      }

      function prepareDisciplineLayout(raw) {
        if (!raw) return null;
        const defs = Array.isArray(raw.clusterDefinitions)
          ? raw.clusterDefinitions.map((def, idx) => ({
              id: def.id || `cluster_${idx}`,
              label: def.label || def.id || `Cluster ${idx + 1}`,
              angleDeg: Number(def.angleDeg) || 0,
            }))
          : [];
        if (!defs.length) return null;
        const sorted = defs
          .map((d) => ({ ...d, angleDeg: normalizeAngleDeg(d.angleDeg) }))
          .sort((a, b) => a.angleDeg - b.angleDeg);
        const clusterById = new Map();
        const total = sorted.length;
        for (let i = 0; i < total; i++) {
          const current = sorted[i];
          const prev = sorted[(i - 1 + total) % total];
          const next = sorted[(i + 1) % total];
          const prevDelta = forwardAngleDelta(prev.angleDeg, current.angleDeg);
          const nextDelta = forwardAngleDelta(current.angleDeg, next.angleDeg);
          const startDeg = current.angleDeg - prevDelta / 2;
          const endDeg = current.angleDeg + nextDelta / 2;
          current.startRad = degToRad(startDeg);
          current.endRad = degToRad(endDeg);
          current.angleRad = degToRad(current.angleDeg);
          current.widthRad = angleSpan(current.startRad, current.endRad);
          current.color = groupColor(current.id || current.label);
          clusterById.set(current.id, current);
        }
        const tagMap = new Map();
        if (raw.tagToCluster && typeof raw.tagToCluster === "object") {
          for (const [tag, cid] of Object.entries(raw.tagToCluster)) {
            if (!tag) continue;
            tagMap.set(tag.trim().toLowerCase(), cid);
          }
        }
        return {
          clusters: sorted,
          clusterById,
          tagToCluster: tagMap,
        };
      }

      function normalizeAngleDeg(deg) {
        const v = deg % 360;
        return v < 0 ? v + 360 : v;
      }
      function forwardAngleDelta(from, to) {
        let diff = normalizeAngleDeg(to) - normalizeAngleDeg(from);
        if (diff <= 0) diff += 360;
        return diff;
      }
      function degToRad(deg) {
        return (deg * Math.PI) / 180;
      }
      function angleSpan(start, end) {
        let span = end - start;
        const tau = Math.PI * 2;
        span = ((span % tau) + tau) % tau;
        return span || tau;
      }

      function buildDisciplineFloor() {
        if (!disciplineLayout || !THREE || typeof Graph.scene !== "function")
          return;
        const scene = Graph.scene();
        if (!scene) return;
        if (disciplineFloor) scene.remove(disciplineFloor);
        const group = new THREE.Group();
        group.renderOrder = -10;

        const base = new THREE.Mesh(
          new THREE.CircleGeometry(DISC_OUTER_RADIUS, 96),
          new THREE.MeshBasicMaterial({
            color: 0x0b0b0b,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide,
            depthWrite: false,
          })
        );
        base.position.z = DISC_FLOOR_Z;
        group.add(base);

        disciplineLayout.clusters.forEach((cluster) => {
          const shape = new THREE.Shape();
          shape.absarc(
            0,
            0,
            DISC_OUTER_RADIUS,
            cluster.startRad,
            cluster.endRad,
            false
          );
          shape.lineTo(
            Math.cos(cluster.endRad) * DISC_INNER_RADIUS,
            Math.sin(cluster.endRad) * DISC_INNER_RADIUS
          );
          shape.absarc(
            0,
            0,
            DISC_INNER_RADIUS,
            cluster.endRad,
            cluster.startRad,
            true
          );
          const geom = new THREE.ShapeGeometry(shape, 1);
          const color = new THREE.Color(cluster.color || "#999999");
          color.lerp(new THREE.Color("#ffffff"), 0.35);
          const mesh = new THREE.Mesh(
            geom,
            new THREE.MeshBasicMaterial({
              color,
              transparent: true,
              opacity: 0.22,
              side: THREE.DoubleSide,
              depthWrite: false,
            })
          );
          mesh.position.z = DISC_FLOOR_Z + 0.6;
          group.add(mesh);

          if (SpriteText) {
            const label = new SpriteText(cluster.label || cluster.id || "");
            label.color = "#b9bcc1";
            label.textHeight = 14;
            const radius = (DISC_INNER_RADIUS + DISC_OUTER_RADIUS) / 2;
            label.position.set(
              Math.cos(cluster.angleRad) * radius,
              Math.sin(cluster.angleRad) * radius,
              DISC_FLOOR_Z + 4
            );
            group.add(label);
          }
        });

        const ring = new THREE.Mesh(
          new THREE.RingGeometry(DISC_INNER_RADIUS, DISC_OUTER_RADIUS, 96),
          new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.08,
            side: THREE.DoubleSide,
            depthWrite: false,
          })
        );
        ring.position.z = DISC_FLOOR_Z + 0.2;
        group.add(ring);

        disciplineFloor = group;
        scene.add(group);
      }

      // ————— TEXT + THUMBNAIL NODES —————
      const TEXT_H = 6; // altezza del testo (world units)
      const IMG_H = 14; // altezza thumbnail (world units)
      let colorMode = "none"; // none | area | cluster

      function getNodeColor(node) {
        if (colorMode === "none") return "#ffffff";
        let key = "";
        if (colorMode === "area")
          key = (Array.isArray(node.areas) && node.areas[0]) || "";
        else if (colorMode === "cluster") key = node.__cluster ?? "";
        key = String(key || "");
        return key ? groupColor(key) : "#cbd5e1";
      }

      function buildNodeObject(node) {
        const group = new THREE.Group();

        // 1) Etichetta testuale (sempre, colorata in base alla selezione)
        if (SpriteText) {
          const label = new SpriteText(node.name || node.id || "");
          const isSel = selectedIds.has(node.id);
          const baseColor = getNodeColor(node);
          label.color = isSel ? "#000000" : baseColor;
          label.textHeight = TEXT_H * textScale;
          label.backgroundColor = isSel
            ? "rgba(255,255,255,0.95)"
            : "rgba(0,0,0,0.5)";
          group.add(label);
        } else {
          // Fallback minimale se SpriteText non c'è
          const dummy = new THREE.Object3D();
          group.add(dummy);
        }

        // 2) Immagini (se presenti): una riga di sprite sotto il titolo
        const urls = imageUrlsForNode(node);
        if (urls.length) {
          const GAP = 2.0;
          const count = Math.min(urls.length, 4); // limita per performance
          const totalW = count * IMG_H + (count - 1) * GAP;
          const startX = -totalW / 2 + IMG_H / 2;
          const rowY = -(TEXT_H * textScale * 1.3);
          const sprites = [];
          for (let i = 0; i < count; i++) {
            const sprite = new THREE.Sprite(
              new THREE.SpriteMaterial({ transparent: true })
            );
            sprite.scale.set(IMG_H, IMG_H, 1);
            sprite.position.set(startX + i * (IMG_H + GAP), rowY, 0);
            sprite.material.depthTest = false;
            sprite.renderOrder = 1;
            group.add(sprite);
            sprites.push(sprite);

            const url = urls[i];
            loadTextureCached(
              url,
              (tex) => {
                sprite.material.map = tex;
                sprite.material.needsUpdate = true;
                const w = tex.image?.width || 1;
                const h = tex.image?.height || 1;
                const r = h / w;
                sprite.scale.set(IMG_H, IMG_H * r, 1);
              },
              () => {
                group.remove(sprite);
              }
            );
          }
        }

        // 3) Hitbox invisibile per facilitare la selezione (bounding box)
        const name = String(node.name || node.id || "");
        const w = Math.max(60, Math.min(260, name.length * (TEXT_H * 1.6)));
        const h = TEXT_H * 2.0 + (urls.length ? IMG_H * 1.6 : 0);
        const plane = new THREE.Mesh(
          new THREE.PlaneGeometry(w, h),
          new THREE.MeshBasicMaterial({
            transparent: true,
            opacity: 0,
            depthTest: false,
          })
        );
        plane.position.set(0, urls.length ? -IMG_H * 0.3 : 0, -0.01);
        group.add(plane);

        return group;
      }

      function refreshNodeRenderer() {
        Graph.nodeThreeObject(buildNodeObject).nodeThreeObjectExtend(true);
      }

      // inizializza renderer nodi
      refreshNodeRenderer();

      // === Selezione e pannello ===
      function $(sel) {
        return document.querySelector(sel);
      }
      function selectOnly(id) {
        selectedIds = new Set(id ? [id] : []);
        updateEditor();
        refreshNodeRenderer();
      }
      function toggleSelection(id) {
        if (!id) return;
        if (selectedIds.has(id)) selectedIds.delete(id);
        else selectedIds.add(id);
        updateEditor();
        refreshNodeRenderer();
      }
      function getSingleSelectedId() {
        return selectedIds.size === 1 ? [...selectedIds][0] : null;
      }
      function updateEditor() {
        const panel = document.getElementById("editor");
        const selInfo = document.getElementById("selInfo");
        if (selectedIds.size !== 1) {
          panel.style.display = "none";
          selInfo.textContent = selectedIds.size
            ? `${selectedIds.size} nodi selezionati`
            : "";
          return;
        }
        const sid = getSingleSelectedId();
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) {
          panel.style.display = "none";
          selInfo.textContent = "";
          return;
        }
        panel.style.display = "block";
        selInfo.textContent = `Selezionato: ${n.name || n.id}`;
        $("#fTitle").value = n.name || "";
        $("#fDate").value = n.date || "";
        $("#fAreas").value = (n.areas || []).join(", ");
        $("#fTags").value = (n.tags || []).join(", ");
        $("#fDesc").value = n.desc || "";
        renderFilesListFor(n);
      }
      function renderFilesListFor(n) {
        const list = $("#filesList");
        const files = n.files || [];
        if (!files.length) {
          list.innerHTML = "";
          return;
        }
        list.innerHTML = files
          .map((file, i) => {
            const name = escapeHtml(file.name || "file");
            const size = file.size
              ? ` — ${Math.round(file.size / 1024)} KB`
              : "";
            const thumb =
              file.isImage && file.url
                ? `<img class=\"thumb\" src=\"${escapeHtml(file.url)}\">`
                : "";
            return `<div class=\"file-row\"><div class=\"file-left\">${thumb}<div class=\"name\">• ${name}${size}</div></div><div class=\"remove\" data-idx=\"${i}\">Remove</div></div>`;
          })
          .join("");
      }

      // Calcolo cluster (grappoli) come componenti connesse
      function computeClusters(nodes, links) {
        const idSet = new Set(nodes.map((n) => n.id));
        const adj = new Map();
        for (const id of idSet) adj.set(id, new Set());
        for (const l of links || []) {
          const s = typeof l.source === "object" ? l.source?.id : l.source;
          const t = typeof l.target === "object" ? l.target?.id : l.target;
          if (s == null || t == null) continue;
          if (!adj.has(s)) adj.set(s, new Set());
          if (!adj.has(t)) adj.set(t, new Set());
          adj.get(s).add(t);
          adj.get(t).add(s);
        }
        const comp = new Map();
        let c = 0;
        for (const id of idSet) {
          if (comp.has(id)) continue;
          const stack = [id];
          comp.set(id, c);
          while (stack.length) {
            const u = stack.pop();
            for (const v of adj.get(u) || []) {
              if (!comp.has(v)) {
                comp.set(v, c);
                stack.push(v);
              }
            }
          }
          c++;
        }
        return comp; // Map id -> clusterIndex
      }

      // Normalizza i dati: link sempre come id, copia pulita dei campi
      function normalizeData(d) {
        const nodes = (d?.nodes || []).map((n) => ({
          id: n.id,
          name: n.name || "",
          date: n.date || "",
          group: n.group || "",
          type: n.type || "",
          areas: Array.isArray(n.areas) ? [...n.areas] : [],
          tags: Array.isArray(n.tags) ? [...n.tags] : [],
          desc: n.desc || "",
          image: n.image || null,
          files: (n.files || []).map((f) => ({
            name: f.name,
            size: f.size,
            isImage: !!f.isImage,
            isPDF: !!f.isPDF,
            path: f.path || null,
            url: f.url || null,
          })),
        }));
        const idSet = new Set(nodes.map((n) => n.id));
        const links = (d?.links || [])
          .map((l) => {
            const s = typeof l.source === "object" ? l.source?.id : l.source;
            const t = typeof l.target === "object" ? l.target?.id : l.target;
            return { source: s, target: t, dashed: !!l.dashed };
          })
          .filter((l) => idSet.has(l.source) && idSet.has(l.target));
        return { nodes, links };
      }

      // Wrapper per impostare i dati e assegnare i cluster (senza mutare currentData)
      function setGraphData(data) {
        const clean = normalizeData(data || { nodes: [], links: [] });
        try {
          const comp = computeClusters(clean.nodes || [], clean.links || []);
          (clean.nodes || []).forEach((n) => {
            n.__cluster = comp.get(n.id) ?? 0;
          });
        } catch (e) {
          (clean.nodes || []).forEach((n) => (n.__cluster = 0));
        }
        Graph.graphData(clean);
        applyDisciplineLayout();
        refreshNodeRenderer();
        setTimeout(() => Graph.zoomToFit(600, 60), 300);
        selectedEdge = null;
        ensureLinkStyleRefresh();
      }

      function ensureLinkStyleRefresh() {
        Graph.linkWidth((l) =>
          isEdgeSelected(l) ? 3 : l.dashed ? 0.6 : 1.4
        ).linkColor((l) =>
          isEdgeSelected(l)
            ? "rgba(255,255,255,0.95)"
            : l.dashed
            ? "rgba(200,200,200,0.25)"
            : "rgba(220,220,220,0.45)"
        );
      }

      // —— Palette colore deterministica (by group) ——
      const PALETTE = [
        "#7aa2f7",
        "#9ece6a",
        "#f7768e",
        "#bb9af7",
        "#e0af68",
        "#2ac3de",
        "#c0caf5",
        "#73daca",
        "#7dcfff",
        "#f6bd60",
        "#ee6c4d",
        "#84a59d",
        "#f28482",
        "#82aaff",
        "#ffd166",
      ];
      function groupColor(g) {
        if (!g) return "#cbd5e1";
        let h = 0;
        for (let i = 0; i < g.length; i++) h = (h * 31 + g.charCodeAt(i)) >>> 0;
        return PALETTE[h % PALETTE.length];
      }

      const DATE_HEIGHT = 240;
      const DATE_BASE_Z = DISC_FLOOR_Z + 14;

      function applyDisciplineLayout() {
        if (!disciplineLayout || typeof Graph.graphData !== "function")
          return;
        const gd = Graph.graphData();
        if (!gd || !Array.isArray(gd.nodes)) return;
        const nodes = gd.nodes;
        const buckets = new Map();
        nodes.forEach((node) => {
          const cid = inferClusterForNode(node);
          node.__disciplineCluster = cid;
          if (!buckets.has(cid)) buckets.set(cid, []);
          buckets.get(cid).push(node);
        });
        const dateStats = collectDateStats(nodes);
        buckets.forEach((list, cid) => {
          const cluster = cid ? disciplineLayout.clusterById.get(cid) : null;
          list.forEach((node, idx) => {
            const angle = pickAngleFor(node, cluster, idx);
            const radius = pickRadiusFor(node, cluster, idx);
            const z = pickHeightFor(node, dateStats);
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            node.x = x;
            node.y = y;
            node.z = z;
            node.fx = x;
            node.fy = y;
            node.fz = z;
          });
        });
        if (Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();
      }

      function inferClusterForNode(node) {
        if (!disciplineLayout || !node) return null;
        const tags = Array.isArray(node.tags) ? node.tags : [];
        for (const raw of tags) {
          const tag = String(raw || "").trim().toLowerCase();
          if (!tag) continue;
          const mapped = disciplineLayout.tagToCluster.get(tag);
          if (mapped) return mapped;
        }
        return null;
      }

      function pickAngleFor(node, cluster, idx) {
        if (cluster) {
          const jitter = hashToUnit(`${node.id || idx}:angle`);
          return cluster.startRad + cluster.widthRad * jitter;
        }
        return hashToUnit(`${node.id || idx}:fallback`) * Math.PI * 2;
      }

      function pickRadiusFor(node, cluster, idx) {
        const min = cluster ? DISC_INNER_RADIUS + 10 : DISC_INNER_RADIUS * 0.4;
        const max = DISC_OUTER_RADIUS - 15;
        const spread = Math.max(0, max - min);
        const jitter = hashToUnit(`${node.id || idx}:radius`);
        const offset = Math.floor(idx / 24) * 18;
        return Math.min(max, min + offset + jitter * spread * 0.9);
      }

      function pickHeightFor(node, stats) {
        const ts = parseNodeDate(node?.date);
        if (!stats || !Number.isFinite(ts)) return DATE_BASE_Z + DATE_HEIGHT * 0.35;
        if (stats.min === stats.max) return DATE_BASE_Z + DATE_HEIGHT * 0.5;
        const ratio = (ts - stats.min) / (stats.max - stats.min);
        const clamped = Math.max(0, Math.min(1, ratio));
        return DATE_BASE_Z + clamped * DATE_HEIGHT;
      }

      function collectDateStats(nodes) {
        let min = Infinity;
        let max = -Infinity;
        for (const n of nodes || []) {
          const ts = parseNodeDate(n?.date);
          if (!Number.isFinite(ts)) continue;
          if (ts < min) min = ts;
          if (ts > max) max = ts;
        }
        if (!Number.isFinite(min) || !Number.isFinite(max)) return null;
        return { min, max };
      }

      function parseNodeDate(value) {
        if (!value) return NaN;
        const parsed = Date.parse(value);
        return Number.isNaN(parsed) ? NaN : parsed;
      }

      function hashToUnit(str) {
        const s = String(str || "");
        let h = 0;
        for (let i = 0; i < s.length; i++) {
          h = (h * 131 + s.charCodeAt(i)) >>> 0;
        }
        return (h & 0xfffffff) / 0xfffffff;
      }

      // —— Tooltip ricco su hover ——
      function showTip(node) {
        const tip = document.getElementById("tooltip");
        if (!node) {
          tip.style.display = "none";
          window.onmousemove = null;
          return;
        }
        const tags = (node.tags || []).join(", ");
        const areas = (node.areas || []).join(", ");
        const fields = [
          node.type ? `<div><b>Type:</b> ${escapeHtml(node.type)}</div>` : "",
          areas ? `<div><b>Areas:</b> ${escapeHtml(areas)}</div>` : "",
          tags ? `<div><b>Tags:</b> ${escapeHtml(tags)}</div>` : "",
          node.group
            ? `<div><b>Group:</b> ${escapeHtml(node.group)}</div>`
            : "",
        ]
          .filter(Boolean)
          .join("");
        const imgHtml =
          node.image || node.img
            ? `<div style="margin-top:6px">
                     <img src="${escapeHtml(
                       resolveImageURL(node.image || node.img)
                     )}"
                          style="max-width:240px;max-height:160px;display:block;border:1px solid rgba(255,255,255,.2)"/>
                   </div>`
            : "";
        tip.innerHTML = `
                <div style="font-weight:700">${escapeHtml(
                  node.name || node.id || ""
                )}</div>
                ${fields}
                ${
                  node.desc
                    ? `<div style="margin-top:8px; white-space:pre-wrap">${escapeHtml(
                        node.desc
                      )}</div>`
                    : ""
                }
                ${imgHtml}
              `;
        tip.style.display = "block";
        window.onmousemove = (e) => {
          tip.style.left = e.clientX + 12 + "px";
          tip.style.top = e.clientY + 12 + "px";
        };
      }
      function escapeHtml(s) {
        if (!s) return "";
        return ("" + s).replace(
          /[&<>\"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }

      // —— Toolbar actions ——
      document.getElementById("btnFit").onclick = () => {
        Graph.zoomToFit(600, 60);
      };
      document.getElementById("btnToggleSize").onclick = () => {
        textScale = textScale >= 1.6 ? 0.8 : textScale + 0.2;
        refreshNodeRenderer();
      };

      document.getElementById("colorBy").onchange = (e) => {
        colorMode = e.target.value;
        refreshNodeRenderer();
      };

      // Toggle 3D/2D
      (function init2DToggle() {
        const chk2D = document.getElementById("chk2D");
        if (!chk2D) return;
        chk2D.checked = false; // 3D di default
        chk2D.addEventListener("change", () => setView2D(!!chk2D.checked));
      })();

      function setView2D(on) {
        is2D = !!on;
        // Prova a portare la simulazione a 2 dimensioni (se supportato)
        try {
          Graph.numDimensions(is2D ? 2 : 3);
        } catch (e) {}

        const controls = Graph.controls ? Graph.controls() : null;
        if (controls) {
          controls.enableRotate = !is2D;
          controls.enablePan = true;
          controls.enableZoom = true;
          if (typeof THREE !== "undefined" && controls.mouseButtons) {
            try {
              controls.mouseButtons.LEFT = is2D
                ? THREE.MOUSE.PAN
                : THREE.MOUSE.ROTATE;
            } catch {}
          }
          controls.update && controls.update();
        }

        if (is2D) {
          // Appiattisci z e imposta una vista dall'alto con z costante
          const gd = Graph.graphData && Graph.graphData();
          if (gd && Array.isArray(gd.nodes)) {
            gd.nodes.forEach((n) => {
              n.z = 0;
            });
            Graph.graphData(gd);
          }
          try {
            const cam = Graph.camera && Graph.camera();
            if (cam) {
              cam.position.set(0, 0, TWO_D_Z);
              cam.up.set(0, 1, 0);
              if (cam.lookAt) cam.lookAt(0, 0, 0);
            }
          } catch {}
          setTimeout(() => Graph.zoomToFit(600, 60), 50);
        } else {
          // Torna alla vista 3D; mantieni controlli predefiniti
          setTimeout(() => Graph.zoomToFit(600, 60), 50);
        }
      }

      // Toolbar extra
      document.getElementById("btnNewNode").onclick = () => addNewNode();
      document.getElementById("btnConnect").onclick = () =>
        connectSelectedNodes();
      document.getElementById("btnSpawn").onclick = () =>
        spawnChildFromSelected();
      document.getElementById("btnDelete").onclick = () => deleteSelected();
      document.getElementById("btnUndo").onclick = () => undo();
      document.getElementById("btnRedo").onclick = () => redo();
      document.getElementById("btnOpenFolder").onclick = async () => {
        try {
          await openProjectFromFolder();
        } catch (e) {
          alert(e.message || e);
        }
      };
      document.getElementById("btnSave").onclick = async () => {
        try {
          await saveProjectSmart();
        } catch (e) {
          alert(e.message || e);
        }
      };
      // POV toggle (default off)
      let camOnSelect = false;
      const chkPOV = document.getElementById("chkPOV");
      if (chkPOV)
        chkPOV.addEventListener("change", () => {
          camOnSelect = !!chkPOV.checked;
        });

      // Rimosso il caricamento rapido di graphdata.json

      // Tooltip su hover per la toolbar
      (function attachToolbarTooltips() {
        const tip = document.getElementById("tooltip");
        const bar = document.querySelector(".toolbar");
        if (!tip || !bar) return;
        function show(text, x, y) {
          tip.textContent = text;
          tip.style.display = "block";
          tip.style.left = x + 12 + "px";
          tip.style.top = y + 12 + "px";
        }
        function hide() {
          tip.style.display = "none";
        }
        bar.addEventListener("mouseover", (e) => {
          const el = e.target.closest("button, select, label");
          if (!el) return;
          const t =
            el.getAttribute("data-tip") || el.title || el.textContent.trim();
          if (!t) return;
          show(t, e.clientX, e.clientY);
        });
        bar.addEventListener("mousemove", (e) => {
          if (tip.style.display === "block") {
            tip.style.left = e.clientX + 12 + "px";
            tip.style.top = e.clientY + 12 + "px";
          }
        });
        bar.addEventListener("mouseout", (e) => {
          if (!bar.contains(e.relatedTarget)) hide();
        });
      })();

      // Rimosso il picker JSON: usa Apri cartella per caricare/salvare

      function isGraphData(d) {
        return (
          d &&
          Array.isArray(d.nodes) &&
          Array.isArray(d.links) &&
          (d.nodes.length === 0 || d.nodes[0].id !== undefined) &&
          (d.links.length === 0 ||
            ("source" in d.links[0] && "target" in d.links[0]))
        );
      }
      function isThreadscape(d) {
        return (
          d && d.version && Array.isArray(d.nodes) && Array.isArray(d.edges)
        );
      }
      function convertProjectToGraphData(project) {
        const nodes = (project.nodes || []).map((n) => {
          const d = n.data || {};
          const image = pickNodeImageFromFiles(d.files);

          return {
            id: n.id,
            name: d.title || n.id,
            date: d.date || n.date || "",
            // main area / type non usati in questa vista
            group: "",
            type: "",
            areas: d.areas || [],
            tags: d.tags || [],
            desc: d.desc || "",
            image,
            files: (d.files || []).map((f) => ({
              name: f.name,
              size: f.size,
              isImage: !!f.isImage,
              isPDF: !!f.isPDF,
              path: f.path || null,
              url: f.url || (f.path ? resolveImageURL(f.path) : null),
            })),
          };
        });

        const seen = new Set();
        const links = (project.edges || [])
          .map((e) => {
            const s = e.s,
              t = e.t;
            const key = [s, t].sort().join("||"); // nondirezionale + dedup
            if (seen.has(key)) return null;
            seen.add(key);
            return { source: s, target: t, dashed: !!e.dashed };
          })
          .filter(Boolean);

        return { nodes, links };
      }

      // === Undo/redo helper ===
      function uid() {
        return "n" + Math.random().toString(36).slice(2, 9);
      }
      function deepClone(x) {
        return JSON.parse(JSON.stringify(x));
      }
      function pushHistory() {
        history.undo.push(deepClone(normalizeData(currentData)));
        if (history.undo.length > history.limit) history.undo.shift();
        history.redo.length = 0;
      }
      function undo() {
        if (!history.undo.length) return;
        history.redo.push(deepClone(normalizeData(currentData)));
        currentData = history.undo.pop();
        setGraphData(currentData);
        selectOnly(null);
      }
      function redo() {
        if (!history.redo.length) return;
        history.undo.push(deepClone(normalizeData(currentData)));
        currentData = history.redo.pop();
        setGraphData(currentData);
        selectOnly(null);
      }

      // === Azioni sui nodi ===
      function spawnChildFromSelected() {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const parent = currentData.nodes.find((n) => n.id === sid);
        if (!parent) return;
        pushHistory();
        const id = uid();
        const child = {
          id,
          name: "Nuovo nodo",
          date: parent.date || "",
          areas: [...(parent.areas || [])],
          tags: [],
          desc: "",
          files: [],
        };
        currentData.nodes.push(child);
        currentData.links.push({ source: parent.id, target: id });
        setGraphData(currentData);
        selectOnly(id);
      }
      function deleteSelected() {
        if (!selectedIds.size) return;
        pushHistory();
        const del = new Set(selectedIds);
        currentData.nodes = currentData.nodes.filter((n) => !del.has(n.id));
        currentData.links = currentData.links.filter((l) => {
          const s = typeof l.source === "object" ? l.source?.id : l.source;
          const t = typeof l.target === "object" ? l.target?.id : l.target;
          return !del.has(s) && !del.has(t);
        });
        setGraphData(currentData);
        selectOnly(null);
      }

      function connectSelectedNodes() {
        if (selectedIds.size !== 2) {
          setStatus("Seleziona 2 nodi");
          return;
        }
        const [a, b] = [...selectedIds];
        if (a === b) return;
        // evita duplicati (nondirezionale)
        const key = (x, y) => [x, y].sort().join("||");
        const existing = new Set(
          (currentData.links || []).map((l) =>
            key(
              typeof l.source === "object" ? l.source?.id : l.source,
              typeof l.target === "object" ? l.target?.id : l.target
            )
          )
        );
        const k = key(a, b);
        if (existing.has(k)) {
          setStatus("Già collegati");
          return;
        }
        pushHistory();
        currentData.links.push({ source: a, target: b });
        setGraphData(currentData);
        setStatus("Nodi collegati");
      }

      function addNewNode() {
        pushHistory();
        const id = uid();
        currentData.nodes.push({
          id,
          name: "Nuovo nodo",
          date: "",
          areas: [],
          tags: [],
          desc: "",
          files: [],
        });
        setGraphData(currentData);
        selectOnly(id);
        setStatus("Nuovo nodo creato");
      }

      // === Editor bindings ===
      document.getElementById("fTitle").addEventListener("input", () => {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) return;
        n.name = document.getElementById("fTitle").value.trim();
        syncGraphNodeById(sid);
        refreshNodeRenderer();
      });
      document.getElementById("fDate").addEventListener("change", () => {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) return;
        n.date = document.getElementById("fDate").value || "";
        syncGraphNodeById(sid);
        applyDisciplineLayout();
      });
      document.getElementById("fAreas").addEventListener("change", () => {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) return;
        const raw = document.getElementById("fAreas").value || "";
        n.areas = raw.split(/,\s*/).filter(Boolean);
        syncGraphNodeById(sid);
        refreshNodeRenderer();
      });
      document.getElementById("fTags").addEventListener("change", () => {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) return;
        const raw = document.getElementById("fTags").value || "";
        n.tags = raw.split(/,\s*/).filter(Boolean);
        syncGraphNodeById(sid);
        applyDisciplineLayout();
      });
      document.getElementById("fDesc").addEventListener("change", () => {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) return;
        n.desc = document.getElementById("fDesc").value;
        syncGraphNodeById(sid);
      });

      document
        .getElementById("btnAddFiles")
        .addEventListener("click", () =>
          document.getElementById("fFiles").click()
        );
      document.getElementById("fFiles").addEventListener("change", () => {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) return;
        const inp = document.getElementById("fFiles");
        const fls = Array.from(inp.files || []);
        n.files = n.files || [];
        for (const f of fls) {
          const entry = {
            name: f.name,
            size: f.size,
            isImage: /^image\//i.test(f.type),
            isPDF: /pdf$/i.test(f.type) || /\.pdf$/i.test(f.name),
            path: "assets/" + f.name,
            url: URL.createObjectURL(f),
            __file: f,
          };
          n.files.push(entry);
        }
        const firstImg = (n.files || []).find((x) => x.isImage);
        n.image = firstImg ? firstImg.url : n.image;
        syncGraphNodeById(sid);
        renderFilesListFor(n);
        refreshNodeRenderer();
        inp.value = "";
      });
      document.getElementById("filesList").addEventListener("click", (e) => {
        const rm = e.target.closest(".remove");
        if (!rm) return;
        const sid = getSingleSelectedId();
        if (!sid) return;
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) return;
        const idx = Number(rm.getAttribute("data-idx"));
        if (!Number.isFinite(idx)) return;
        n.files.splice(idx, 1);
        const firstImg = (n.files || []).find((x) => x.isImage);
        n.image = firstImg
          ? firstImg.url || resolveImageURL(firstImg.path)
          : null;
        syncGraphNodeById(sid);
        renderFilesListFor(n);
        refreshNodeRenderer();
      });

      // sincronizza i cambi di currentData sul grafo vivo
      function syncGraphNodeById(id) {
        const gd = Graph.graphData();
        if (!gd) return;
        const gn = (gd.nodes || []).find((x) => x.id === id);
        if (!gn) return;
        const src = (currentData.nodes || []).find((x) => x.id === id);
        if (!src) return;
        gn.name = src.name || "";
        gn.date = src.date || "";
        gn.areas = Array.isArray(src.areas) ? [...src.areas] : [];
        gn.tags = Array.isArray(src.tags) ? [...src.tags] : [];
        gn.desc = src.desc || "";
        gn.image = src.image || null;
        gn.files = Array.isArray(src.files)
          ? src.files.map((f) => ({ ...f }))
          : [];
      }

      // === File System Access: open/save ===
      const projectCtx = { dirHandle: null };
      async function openProjectFromFolder() {
        if (!("showDirectoryPicker" in window))
          throw new Error("Il browser non supporta l'apertura cartelle");
        const dir = await window.showDirectoryPicker({ mode: "readwrite" });
        const found = await findProjectJson(dir);
        if (!found)
          throw new Error(
            "project.json non trovato nella cartella selezionata"
          );
        const { root, fileHandle } = found;
        const file = await fileHandle.getFile();
        const text = await file.text();
        const project = JSON.parse(text);
        if (!isThreadscape(project))
          throw new Error("project.json non è nel formato Threadscape");
        projectCtx.dirHandle = root;
        pushHistory();
        currentData = normalizeData(convertProjectToGraphData(project));
        await attachObjectURLsFromDir(root, currentData);
        setGraphData(currentData);
        selectOnly(null);
        setStatus("Nodo/i eliminati");
      }

      // Cerca ricorsivamente project.json partendo dalla cartella scelta
      async function findProjectJson(root, depth = 0, maxDepth = 4) {
        if (!root || depth > maxDepth) return null;
        // prova nella root corrente
        try {
          const fh = await root.getFileHandle("project.json", {
            create: false,
          });
          if (fh) return { root, fileHandle: fh };
        } catch {}
        // altrimenti scansiona sottocartelle
        try {
          for await (const [name, handle] of root.entries()) {
            if (handle.kind === "directory") {
              const found = await findProjectJson(handle, depth + 1, maxDepth);
              if (found) return found;
            }
          }
        } catch {}
        return null;
      }
      async function attachObjectURLsFromDir(dir, data) {
        for (const n of data.nodes || []) {
          for (const f of n.files || []) {
            if (!f.path) continue;
            // prova percorso così com'è, poi fallback a assets/<basename>
            const base = String(f.path).replace(/^\.\/?/, "");
            const cand = [base];
            const bn = base.split(/[\\\/]*/).pop() || base;
            if (!/^assets\//i.test(base)) cand.push("assets/" + bn);
            let file = null;
            for (const p of cand) {
              try {
                file = await readFileByPath(dir, p);
                if (file) {
                  f.path = p;
                  break;
                }
              } catch {}
            }
            if (file) {
              try {
                if (f.url && String(f.url).startsWith("blob:"))
                  URL.revokeObjectURL(f.url);
              } catch {}
              f.url = URL.createObjectURL(file);
              f.size = file.size;
            }
          }
          // aggiorna thumbnail 3D con la prima immagine disponibile
          const firstImg = (n.files || []).find((x) => x && x.isImage && x.url);
          if (firstImg && firstImg.url) n.image = firstImg.url;
        }
      }
      async function saveProjectSmart() {
        if (projectCtx.dirHandle) {
          await saveProjectToDir(projectCtx.dirHandle);
          alert("Salvato");
        } else if ("showDirectoryPicker" in window) {
          const dir = await window.showDirectoryPicker({ mode: "readwrite" });
          projectCtx.dirHandle = dir;
          await saveProjectToDir(dir);
          alert("Salvato in nuova cartella");
        } else {
          const blob = new Blob(
            [JSON.stringify(buildProjectObject(), null, 2)],
            { type: "application/json" }
          );
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "project.json";
          a.click();
        }
      }
      function buildProjectObject() {
        const nodes = (currentData.nodes || []).map((n) => {
          const files = (n.files || []).map((f) => ({
            name: f.name,
            size: f.size,
            isImage: !!f.isImage,
            isPDF: !!f.isPDF,
            path: f.path || null,
          }));
          // Esporta senza type e mainArea
          return {
            id: n.id,
            data: {
              date: n.date || "",
              title: n.name || n.id,
              type: "",
              mainArea: null,
              areas: n.areas || [],
              tags: n.tags || [],
              desc: n.desc || "",
              files,
            },
          };
        });
        const edges = (currentData.links || []).map((l) => ({
          s: typeof l.source === "object" ? l.source?.id : l.source,
          t: typeof l.target === "object" ? l.target?.id : l.target,
          dashed: !!l.dashed,
        }));
        return { version: 6, nodes, edges };
      }
      async function writeFileByPath(root, relPath, blob) {
        const parts = relPath.split("/").filter(Boolean);
        let dir = root;
        for (let i = 0; i < parts.length - 1; i++) {
          dir = await dir.getDirectoryHandle(parts[i], { create: true });
        }
        const fileHandle = await dir.getFileHandle(parts[parts.length - 1], {
          create: true,
        });
        const w = await fileHandle.createWritable();
        await w.write(blob);
        await w.close();
      }
      async function readFileByPath(root, relPath) {
        const parts = relPath.split("/").filter(Boolean);
        let dir = root;
        for (let i = 0; i < parts.length - 1; i++) {
          dir = await dir.getDirectoryHandle(parts[i], { create: false });
        }
        const fileHandle = await dir.getFileHandle(parts[parts.length - 1], {
          create: false,
        });
        return await fileHandle.getFile();
      }
      async function saveProjectToDir(dir) {
        for (const n of currentData.nodes || []) {
          for (const f of n.files || []) {
            if (f.__file) {
              const name = sanitizeFileName(f.__file.name || "file");
              const rel = f.path || "assets/" + name;
              let blob = f.__file;
              if (f.isImage) {
                try {
                  blob = await resizeImageFile(f.__file, 1700);
                } catch {}
              }
              await writeFileByPath(dir, rel, blob);
              f.path = rel;
              f.size = blob.size;
              // aggiorna subito l'Object URL dalla copia su disco
              try {
                const of = await readFileByPath(dir, rel);
                if (of) {
                  if (f.url)
                    try {
                      URL.revokeObjectURL(f.url);
                    } catch {}
                  f.url = URL.createObjectURL(of);
                }
              } catch {}
            } else if (f.path && !f.url) {
              // se esiste già su disco ma manca url, crealo ora
              try {
                const of = await readFileByPath(dir, f.path);
                if (of) f.url = URL.createObjectURL(of);
              } catch {}
            }
          }
        }
        const project = buildProjectObject();
        const blob = new Blob([JSON.stringify(project, null, 2)], {
          type: "application/json",
        });
        await writeFileByPath(dir, "project.json", blob);
        // riallinea anteprime e thumbnail dal disco appena scritto
        try {
          await attachObjectURLsFromDir(dir, currentData);
          const sid = getSingleSelectedId();
          if (sid) {
            const n = currentData.nodes.find((x) => x.id === sid);
            if (n) renderFilesListFor(n);
          }
          refreshNodeRenderer();
        } catch {}
      }

      function sanitizeFileName(name) {
        return String(name).replace(/[^a-zA-Z0-9._-]+/g, "_");
      }

      function resizeImageFile(file, maxSide = 1700) {
        return new Promise((resolve) => {
          try {
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
              const iw = img.naturalWidth || img.width;
              const ih = img.naturalHeight || img.height;
              let tw = iw,
                th = ih;
              const longSide = Math.max(iw, ih);
              if (longSide > maxSide) {
                const scale = maxSide / longSide;
                tw = Math.round(iw * scale);
                th = Math.round(ih * scale);
              }
              if (tw === iw && th === ih) {
                URL.revokeObjectURL(url);
                resolve(file);
                return;
              }
              const canvas = document.createElement("canvas");
              canvas.width = tw;
              canvas.height = th;
              const ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0, tw, th);
              const outType = /^image\//i.test(file.type)
                ? file.type
                : "image/jpeg";
              const quality = outType === "image/jpeg" ? 0.85 : 0.92;
              canvas.toBlob(
                (blob) => {
                  URL.revokeObjectURL(url);
                  resolve(blob || file);
                },
                outType,
                quality
              );
            };
            img.onerror = () => {
              URL.revokeObjectURL(url);
              resolve(file);
            };
            img.src = url;
          } catch {
            resolve(file);
          }
        });
      }

      // Shortcut da tastiera (con guardie per i campi di testo)
      window.addEventListener("keydown", (e) => {
        const isMac = navigator.platform.toUpperCase().includes("MAC");
        const mod = isMac ? e.metaKey : e.ctrlKey;
        const t = e.target;
        const tag = (t && t.tagName ? t.tagName : "").toLowerCase();
        const type = t && t.type ? String(t.type).toLowerCase() : "";
        const isEditable =
          (t && t.isContentEditable) || tag === "textarea" || tag === "input";
        const isTyping =
          isEditable &&
          !["button", "checkbox", "radio", "file", "submit", "reset"].includes(
            type
          );

        // Lascia all'input i tasti Undo/Redo e Canc/Backspace
        if (isTyping) {
          if (mod && e.key.toLowerCase() === "z") return; // undo/redo nativo del campo
          if (!mod && (e.key === "Delete" || e.key === "Backspace")) return; // non eliminare nodi se sto scrivendo
          if (!mod && e.key.toLowerCase() === "c") return; // non catturare 'c' mentre scrivo
        }

        if (mod && e.key.toLowerCase() === "z") {
          e.preventDefault();
          if (e.shiftKey) redo();
          else undo();
        } else if (mod && e.key.toLowerCase() === "s") {
          e.preventDefault();
          saveProjectSmart();
        } else if (mod && e.key.toLowerCase() === "o") {
          e.preventDefault();
          openProjectFromFolder();
        } else if (e.key === "Delete" || e.key === "Backspace") {
          if (selectedIds.size) {
            e.preventDefault();
            deleteSelected();
          } else if (selectedEdge) {
            e.preventDefault();
            deleteSelectedEdge();
          }
        } else if (!mod && e.key.toLowerCase() === "c") {
          e.preventDefault();
          connectSelectedNodes();
        } else if (e.key === "Escape") {
          if (!isTyping) {
            selectOnly(null);
            selectedEdge = null;
            ensureLinkStyleRefresh();
          }
        }
      });

      // === Edge helper ===
      function linkIds(l) {
        const s = typeof l.source === "object" ? l.source?.id : l.source;
        const t = typeof l.target === "object" ? l.target?.id : l.target;
        return { s, t };
      }
      function sameUndirected(a, b) {
        return (a.s === b.s && a.t === b.t) || (a.s === b.t && a.t === b.s);
      }
      function isEdgeSelected(l) {
        if (!selectedEdge) return false;
        return sameUndirected(linkIds(l), selectedEdge);
      }
      function deleteSelectedEdge() {
        if (!selectedEdge) return;
        pushHistory();
        currentData.links = (currentData.links || []).filter(
          (l) => !sameUndirected(linkIds(l), selectedEdge)
        );
        selectedEdge = null;
        setGraphData(currentData);
        setStatus("Edge eliminato");
      }

      // === Status helper ===
      function setStatus(msg) {
        const el = document.getElementById("status");
        if (!el) return;
        if (!msg) {
          el.style.display = "none";
          el.textContent = "";
          return;
        }
        el.textContent = msg;
        el.style.display = "block";
        clearTimeout(setStatus._t);
        setStatus._t = setTimeout(() => {
          el.style.display = "none";
        }, 1800);
      }
    </script>
  </body>
</html>

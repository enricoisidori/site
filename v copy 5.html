<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Visualizer – Text Nodes</title>
    <style>
      html,
      body,
      #scene {
        height: 100%;
        margin: 0;
        background: #0c0c0c;
        color: #eee;
        font: 14px/1.4 system-ui;
      }
      .toolbar {
        position: fixed;
        top: 8px;
        right: 8px;
        display: flex;
        gap: 8px;
        z-index: 10;
      }
      .toolbar button,
      .toolbar label,
      .toolbar select {
        background: #141414;
        border: 1px solid #333;
        color: #eee;
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      .panel {
        position: fixed;
        left: 8px;
        top: 8px;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid #333;
        padding: 8px;
        border-radius: 8px;
        max-width: 360px;
        backdrop-filter: blur(2px);
      }
      .panel h3 {
        margin: 0 0 6px 0;
        font-size: 13px;
        color: #bbb;
      }
      .muted {
        color: #aaa;
        font-size: 12px;
      }
      .tooltip {
        position: fixed;
        pointer-events: none;
        background: #111;
        border: 1px solid #333;
        color: #eee;
        padding: 6px 8px;
        border-radius: 6px;
        font-size: 12px;
        max-width: 420px;
        display: none;
      }
    </style>
    <!-- Three prima di TUTTO -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <!-- 3d-force-graph -->
    <script src="https://unpkg.com/3d-force-graph"></script>
    <!-- three-spritetext, ORA dopo THREE -->
    <script src="https://unpkg.com/three-spritetext"></script>
    <script>
      // Fail-safe: se per CDN o cache SpriteText fosse namespaced, prendilo da window
      const SpriteText =
        window.SpriteText || window["three-spritetext"] || null;
      if (!SpriteText) {
        console.warn(
          "SpriteText non disponibile; userò le label standard come fallback."
        );
      }
    </script>
  </head>
  <body>
    <div id="scene"></div>

    <div class="toolbar">
      <label>
        <input
          id="file"
          type="file"
          accept="application/json"
          style="display: none"
        />
        Carica JSON…
      </label>
      <button id="btnFit">Fit</button>
      <button id="btnToggleSize">Text ±</button>
      <select id="colorBy" title="Colora per…">
        <option value="none" selected>Colori: Nessuno</option>
        <option value="group">Colori: per Group/Area</option>
        <option value="area">Colori: per Area</option>
        <option value="type">Colori: per Type</option>
        <option value="cluster">Colori: per Cluster</option>
      </select>
    </div>

    <div class="panel">
      <h3>Legenda / Note</h3>
      <div class="muted">
        I nodi sono testo (niente palline). Colore = <em>group</em> (tipicamente
        l’area).
      </div>
      <div class="muted">Hover per dettagli; click per centrare/zoomare.</div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <script>
      const el = document.getElementById("scene");
      const Graph = ForceGraph3D()(el)
        .backgroundColor("#0c0c0c")
        .nodeRelSize(1) // irrilevante: non usiamo le palline
        .nodeLabel(() => "") // niente balloon label, usiamo sprite+tooltip
        .linkOpacity(0.35)
        .linkWidth((l) => (l.dashed ? 0.6 : 1.4))
        .linkColor((l) =>
          l.dashed ? "rgba(200,200,200,0.25)" : "rgba(220,220,220,0.45)"
        )
        .enableNodeDrag(true)
        .onNodeHover((node) => showTip(node))
        .onNodeClick((node) => {
          Graph.centerAt(node.x, node.y, 500);
          Graph.zoom(3, 800);
          lastPinned = node;
        });

      let lastPinned = null;
      let textScale = 1.0; // scala globale del testo

      // —— Helper immagini + cache texture ——
      // Usa l’istanza di THREE disponibile (quella globale esposta anche da 3d-force-graph)
      const THREE = window.THREE;
      // Base per i path relativi (se l'HTML e la cartella "assets/" sono accanto, lascia "./")
      const ASSET_BASE = "./";

      // Risolvi una URL immagine a partire dal campo files.path / dataUrl / url
      function resolveImageURL(raw) {
        if (!raw) return null;
        // data URL o http(s)
        if (/^data:|^https?:\/\//i.test(raw)) return raw;
        // path relativo (es. "assets/xxx.jpg")
        return ASSET_BASE + String(raw).replace(/^\.?\//, "");
      }

      // Trova la prima immagine nel nodo Threadscape (data.files)
      function pickNodeImageFromFiles(files) {
        if (!Array.isArray(files)) return null;
        for (const f of files) {
          if (f && f.isImage) {
            // priorità al path (salvato da “Save to folder”), poi dataUrl/url
            const candidate = f.path || f.dataUrl || f.url;
            const url = resolveImageURL(candidate);
            if (url) return url;
          }
        }
        return null;
      }

      // Texture loader con cache
      const __texCache = new Map();
      const texLoader = new THREE.TextureLoader();
      function loadTextureCached(url, onOk, onErr) {
        if (!url) return onErr && onErr();
        if (__texCache.has(url)) return onOk(__texCache.get(url));
        texLoader.load(
          url,
          (tex) => {
            __texCache.set(url, tex);
            onOk(tex);
          },
          undefined,
          (e) => {
            onErr && onErr(e);
          }
        );
      }

      // ————— TEXT + THUMBNAIL NODES —————
      const TEXT_H = 6; // altezza del testo (world units)
      const IMG_H = 14; // altezza thumbnail (world units)
      let colorMode = "none"; // none | group | area | type | cluster

      function getNodeColor(node) {
        if (colorMode === "none") return "#ffffff";
        let key = "";
        if (colorMode === "group") key = node.group || "";
        else if (colorMode === "area") key = (Array.isArray(node.areas) && node.areas[0]) || node.group || "";
        else if (colorMode === "type") key = node.type || "";
        else if (colorMode === "cluster") key = (node.__cluster ?? "");
        key = String(key || "");
        return key ? groupColor(key) : "#cbd5e1";
      }

      function buildNodeObject(node) {
        const group = new THREE.Group();

        // 1) Etichetta testuale (sempre, colorata in base alla selezione)
        if (SpriteText) {
          const label = new SpriteText(node.name || node.id || "");
          label.color = getNodeColor(node);
          label.textHeight = TEXT_H * textScale;
          label.backgroundColor = "rgba(0,0,0,0.5)";
          group.add(label);
        } else {
          // Fallback minimale se SpriteText non c'è
          const dummy = new THREE.Object3D();
          group.add(dummy);
        }

        // 2) Immagine (se presente): node.image o node.img
        const imgUrl = resolveImageURL(node.image || node.img);
        if (imgUrl) {
          const sprite = new THREE.Sprite(
            new THREE.SpriteMaterial({ transparent: true })
          );
          // dimensioni provvisorie finché la texture non è pronta
          sprite.scale.set(IMG_H, IMG_H, 1);
          // posiziona l’immagine sopra il testo
          sprite.position.set(0, IMG_H * 0.6, 0);
          group.add(sprite);

          loadTextureCached(
            imgUrl,
            (tex) => {
              sprite.material.map = tex;
              sprite.material.needsUpdate = true;
              const w = tex.image?.width || 1;
              const h = tex.image?.height || 1;
              const r = h / w;
              sprite.scale.set(IMG_H, IMG_H * r, 1);
            },
            () => {
              // se fallisce il load, togli lo sprite e lascia solo il testo
              group.remove(sprite);
            }
          );
        }

        return group;
      }

      function refreshNodeRenderer() {
        Graph.nodeThreeObject(buildNodeObject).nodeThreeObjectExtend(true);
      }

      // inizializza renderer nodi
      refreshNodeRenderer();

      // Calcolo cluster (grappoli) come componenti connesse
      function computeClusters(nodes, links) {
        const idSet = new Set(nodes.map((n) => n.id));
        const adj = new Map();
        for (const id of idSet) adj.set(id, new Set());
        for (const l of links || []) {
          const s = typeof l.source === 'object' ? l.source?.id : l.source;
          const t = typeof l.target === 'object' ? l.target?.id : l.target;
          if (s == null || t == null) continue;
          if (!adj.has(s)) adj.set(s, new Set());
          if (!adj.has(t)) adj.set(t, new Set());
          adj.get(s).add(t);
          adj.get(t).add(s);
        }
        const comp = new Map();
        let c = 0;
        for (const id of idSet) {
          if (comp.has(id)) continue;
          const stack = [id];
          comp.set(id, c);
          while (stack.length) {
            const u = stack.pop();
            for (const v of adj.get(u) || []) {
              if (!comp.has(v)) {
                comp.set(v, c);
                stack.push(v);
              }
            }
          }
          c++;
        }
        return comp; // Map id -> clusterIndex
      }

      // Wrapper per impostare i dati e assegnare i cluster
      function setGraphData(data) {
        try {
          const comp = computeClusters(data.nodes || [], data.links || []);
          (data.nodes || []).forEach((n) => {
            n.__cluster = comp.get(n.id) ?? 0;
          });
        } catch (e) {
          // fallback: nessun cluster
          (data.nodes || []).forEach((n) => (n.__cluster = 0));
        }
        Graph.graphData(data);
        refreshNodeRenderer();
        setTimeout(() => Graph.zoomToFit(600, 60), 300);
      }

      // —— Palette colore deterministica (by group) ——
      const PALETTE = [
        "#7aa2f7",
        "#9ece6a",
        "#f7768e",
        "#bb9af7",
        "#e0af68",
        "#2ac3de",
        "#c0caf5",
        "#73daca",
        "#7dcfff",
        "#f6bd60",
        "#ee6c4d",
        "#84a59d",
        "#f28482",
        "#82aaff",
        "#ffd166",
      ];
      function groupColor(g) {
        if (!g) return "#cbd5e1";
        let h = 0;
        for (let i = 0; i < g.length; i++) h = (h * 31 + g.charCodeAt(i)) >>> 0;
        return PALETTE[h % PALETTE.length];
      }

      // —— Tooltip ricco su hover ——
      function showTip(node) {
        const tip = document.getElementById("tooltip");
        if (!node) {
          tip.style.display = "none";
          window.onmousemove = null;
          return;
        }
        const tags = (node.tags || []).join(", ");
        const areas = (node.areas || []).join(", ");
        const fields = [
          node.type ? `<div><b>Type:</b> ${escapeHtml(node.type)}</div>` : "",
          areas ? `<div><b>Areas:</b> ${escapeHtml(areas)}</div>` : "",
          tags ? `<div><b>Tags:</b> ${escapeHtml(tags)}</div>` : "",
          node.group
            ? `<div><b>Group:</b> ${escapeHtml(node.group)}</div>`
            : "",
        ]
          .filter(Boolean)
          .join("");
        const imgHtml =
          node.image || node.img
            ? `<div style="margin-top:6px">
               <img src="${escapeHtml(resolveImageURL(node.image || node.img))}"
                    style="max-width:240px;max-height:160px;display:block;border:1px solid rgba(255,255,255,.2)"/>
             </div>`
            : "";
        tip.innerHTML = `
          <div style="font-weight:700">${escapeHtml(
            node.name || node.id || ""
          )}</div>
          ${fields}
          ${
            node.desc
              ? `<div style="margin-top:8px; white-space:pre-wrap">${escapeHtml(
                  node.desc
                )}</div>`
              : ""
          }
          ${imgHtml}
        `;
        tip.style.display = "block";
        window.onmousemove = (e) => {
          tip.style.left = e.clientX + 12 + "px";
          tip.style.top = e.clientY + 12 + "px";
        };
      }
      function escapeHtml(s) {
        if (!s) return "";
        return ("" + s).replace(
          /[&<>\"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }

      // —— Toolbar actions ——
      document.getElementById("btnFit").onclick = () => {
        Graph.zoomToFit(600, 60);
      };
      document.getElementById("btnToggleSize").onclick = () => {
        textScale = textScale >= 1.6 ? 0.8 : textScale + 0.2;
        refreshNodeRenderer();
      };

      document.getElementById("colorBy").onchange = (e) => {
        colorMode = e.target.value;
        refreshNodeRenderer();
      };

      // Rimosso il caricamento rapido di graphdata.json

      document.getElementById("file").onchange = async (e) => {
        const fl = e.target.files[0];
        if (!fl) return;
        const text = await fl.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch (err) {
          return alert("JSON non valido");
        }
        // Accetta sia graphData diretto, sia Threadscape project.json (converte al volo)
        if (isGraphData(data)) {
          setGraphData(data);
        } else if (isThreadscape(data)) {
          setGraphData(convertProjectToGraphData(data));
        } else {
          return alert("Formato non riconosciuto");
        }
      };

      function isGraphData(d) {
        return (
          d &&
          Array.isArray(d.nodes) &&
          Array.isArray(d.links) &&
          (d.nodes.length === 0 || d.nodes[0].id !== undefined) &&
          (d.links.length === 0 ||
            ("source" in d.links[0] && "target" in d.links[0]))
        );
      }
      function isThreadscape(d) {
        return (
          d && d.version && Array.isArray(d.nodes) && Array.isArray(d.edges)
        );
      }
      function convertProjectToGraphData(project) {
        const nodes = (project.nodes || []).map((n) => {
          const d = n.data || {};
          const image = pickNodeImageFromFiles(d.files);

          return {
            id: n.id,
            name: d.title || n.id,
            group: d.mainArea || (d.areas && d.areas[0]) || "Other",
            type: d.type || "",
            areas: d.areas || [],
            tags: d.tags || [],
            desc: d.desc || "",
            image, // nuovo campo usato dal renderer 3D
          };
        });

        const seen = new Set();
        const links = (project.edges || [])
          .map((e) => {
            const s = e.s,
              t = e.t;
            const key = [s, t].sort().join("||"); // nondirezionale + dedup
            if (seen.has(key)) return null;
            seen.add(key);
            return { source: s, target: t, dashed: !!e.dashed };
          })
          .filter(Boolean);

        return { nodes, links };
      }
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Visualizer – Text Nodes</title>
    <style>
      html,
      body,
      #scene {
        height: 100%;
        margin: 0;
        background: #0c0c0c;
        color: #eee;
        font: 14px/1.4 system-ui;
      }
      .toolbar {
        position: fixed;
        top: 8px;
        right: 8px;
        display: flex;
        gap: 8px;
        z-index: 10;
      }
      .toolbar button,
      .toolbar label,
      .toolbar select {
        background: #141414;
        border: 1px solid #333;
        color: #eee;
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      .toolbar .spacer { width: 8px; }
      .panel {
        position: fixed;
        left: 8px;
        top: 8px;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid #333;
        padding: 8px;
        border-radius: 8px;
        max-width: 360px;
        backdrop-filter: blur(2px);
      }
      .panel h3 {
        margin: 0 0 6px 0;
        font-size: 13px;
        color: #bbb;
      }
      .muted {
        color: #aaa;
        font-size: 12px;
      }
      .tooltip {
        position: fixed;
        pointer-events: none;
        background: #111;
        border: 1px solid #333;
        color: #eee;
        padding: 6px 8px;
        border-radius: 6px;
        font-size: 12px;
        max-width: 420px;
        display: none;
      }
      /* Editor laterale */
      .edit-panel {
        position: fixed;
        top: 8px;
        right: 8px;
        width: 360px;
        max-height: calc(100% - 16px);
        overflow: auto;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid #333;
        border-radius: 8px;
        padding: 10px;
        display: none;
        backdrop-filter: blur(2px);
      }
      .edit-panel h3 { margin: 0 0 8px 0; font-size: 13px; color: #bbb; }
      .edit-panel label { display:block; font-size:12px; color:#ddd; margin:10px 0 4px 0; }
      .edit-panel input[type="text"], .edit-panel textarea {
        width: 100%; background: #0f0f0f; color: #eee; border: 1px solid #333;
        border-radius: 6px; padding: 8px 10px; font: inherit;
      }
      .edit-panel textarea { min-height: 120px; resize: vertical; }
      .file-row { display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:12px; padding:6px 0; border-bottom:1px solid #333; }
      .file-left { display:flex; align-items:center; gap:8px; min-width:0; }
      .thumb { width:16px; height:16px; border-radius:3px; border:1px solid #333; object-fit:cover; display:block; }
      .file-row .name { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:220px; }
      .file-row .remove { cursor:pointer; text-decoration:underline; }
      .file-row .remove:hover { color:#fff; }
    </style>
    <!-- Three prima di TUTTO -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <!-- 3d-force-graph -->
    <script src="https://unpkg.com/3d-force-graph"></script>
    <!-- three-spritetext, ORA dopo THREE -->
    <script src="https://unpkg.com/three-spritetext"></script>
    <script>
      // Fail-safe: se per CDN o cache SpriteText fosse namespaced, prendilo da window
      const SpriteText =
        window.SpriteText || window["three-spritetext"] || null;
      if (!SpriteText) {
        console.warn(
          "SpriteText non disponibile; userò le label standard come fallback."
        );
      }
    </script>
  </head>
  <body>
    <div id="scene"></div>

    <div class="toolbar">
      <label>
        <input
          id="file"
          type="file"
          accept="application/json"
          style="display: none"
        />
        Carica JSON…
      </label>
      <button id="btnFit">Fit</button>
      <button id="btnToggleSize">Text ±</button>
      <select id="colorBy" title="Colora per…">
        <option value="none" selected>Colori: Nessuno</option>
        <option value="area">Colori: per Area</option>
        <option value="cluster">Colori: per Cluster</option>
      </select>
      <span class="spacer"></span>
      <button id="btnOpenFolder">Apri cartella</button>
      <button id="btnSave">Salva</button>
      <button id="btnUndo">Undo</button>
      <button id="btnRedo">Redo</button>
      <button id="btnConnect">Collega (C)</button>
      <button id="btnSpawn">Nuovo collegato</button>
      <button id="btnDelete">Elimina</button>
    </div>

    <div class="panel">
      <h3>Legenda / Note</h3>
      <div class="muted">I nodi sono testo (niente palline). Colore per <em>Area</em> o <em>Cluster</em>.</div>
      <div class="muted">Click seleziona e centra; Shift+Click selezione multipla.</div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <aside id="editor" class="edit-panel">
      <h3>Proprietà nodo</h3>
      <div id="selInfo" class="muted"></div>
      <label for="fTitle">Titolo</label>
      <input id="fTitle" type="text" placeholder="Titolo" />
      <label for="fAreas">Areas (separate da virgola)</label>
      <input id="fAreas" type="text" placeholder="Area1, Area2" />
      <label for="fTags">Tags (separati da virgola)</label>
      <input id="fTags" type="text" placeholder="Tag1, Tag2" />
      <label for="fDesc">Descrizione</label>
      <textarea id="fDesc" placeholder="Descrizione"></textarea>
      <div style="margin-top:10px">
        <button id="btnAddFiles">Aggiungi file…</button>
        <input id="fFiles" type="file" multiple style="display:none" />
      </div>
      <div id="filesList" style="margin-top:6px"></div>
    </aside>

    <script>
      const el = document.getElementById("scene");
      const Graph = ForceGraph3D()(el)
        .backgroundColor("#0c0c0c")
        .nodeRelSize(1) // irrilevante: non usiamo le palline
        .nodeLabel(() => "") // niente balloon label, usiamo sprite+tooltip
        .linkOpacity(0.35)
        .linkWidth((l) => (l.dashed ? 0.6 : 1.4))
        .linkColor((l) =>
          l.dashed ? "rgba(200,200,200,0.25)" : "rgba(220,220,220,0.45)"
        )
        .enableNodeDrag(true)
        .onNodeHover((node) => {
          // tooltip disattivato: si usa il pannello laterale su click
        })
        .onNodeClick((node, event) => {
          if (!node) return;
          if (event && event.shiftKey) toggleSelection(node.id);
          else selectOnly(node.id);
          Graph.centerAt(node.x, node.y, 500);
          Graph.zoom(3, 800);
          lastPinned = node;
        });

      let lastPinned = null;
      let textScale = 1.0; // scala globale del testo
      let selectedIds = new Set(); // selezione multipla
      let currentData = { nodes: [], links: [] }; // dati correnti
      const history = { undo: [], redo: [], limit: 50 };

      // —— Helper immagini + cache texture ——
      // Usa l’istanza di THREE disponibile (quella globale esposta anche da 3d-force-graph)
      const THREE = window.THREE;
      // Base per i path relativi (se l'HTML e la cartella "assets/" sono accanto, lascia "./")
      const ASSET_BASE = "./";

      // Risolvi una URL immagine a partire dal campo files.path / dataUrl / url
      function resolveImageURL(raw) {
        if (!raw) return null;
        // data URL o http(s)
        if (/^data:|^https?:\/\//i.test(raw)) return raw;
        // path relativo (es. "assets/xxx.jpg")
        return ASSET_BASE + String(raw).replace(/^\.?\//, "");
      }

      // Trova la prima immagine nel nodo Threadscape (data.files)
      function pickNodeImageFromFiles(files) {
        if (!Array.isArray(files)) return null;
        for (const f of files) {
          if (f && f.isImage) {
            // priorità al path (salvato da “Save to folder”), poi dataUrl/url
            const candidate = f.path || f.dataUrl || f.url;
            const url = resolveImageURL(candidate);
            if (url) return url;
          }
        }
        return null;
      }

      // Texture loader con cache
      const __texCache = new Map();
      const texLoader = new THREE.TextureLoader();
      function loadTextureCached(url, onOk, onErr) {
        if (!url) return onErr && onErr();
        if (__texCache.has(url)) return onOk(__texCache.get(url));
        texLoader.load(
          url,
          (tex) => {
            __texCache.set(url, tex);
            onOk(tex);
          },
          undefined,
          (e) => {
            onErr && onErr(e);
          }
        );
      }

      // ————— TEXT + THUMBNAIL NODES —————
      const TEXT_H = 6; // altezza del testo (world units)
      const IMG_H = 14; // altezza thumbnail (world units)
      let colorMode = "none"; // none | area | cluster

      function getNodeColor(node) {
        if (colorMode === "none") return "#ffffff";
        let key = "";
        if (colorMode === "area") key = (Array.isArray(node.areas) && node.areas[0]) || "";
        else if (colorMode === "cluster") key = (node.__cluster ?? "");
        key = String(key || "");
        return key ? groupColor(key) : "#cbd5e1";
      }

      function buildNodeObject(node) {
        const group = new THREE.Group();

        // 1) Etichetta testuale (sempre, colorata in base alla selezione)
        if (SpriteText) {
          const label = new SpriteText(node.name || node.id || "");
          const isSel = selectedIds.has(node.id);
          const baseColor = getNodeColor(node);
          label.color = isSel ? "#000000" : baseColor;
          label.textHeight = TEXT_H * textScale;
          label.backgroundColor = isSel ? "rgba(255,255,160,0.9)" : "rgba(0,0,0,0.5)";
          group.add(label);
        } else {
          // Fallback minimale se SpriteText non c'è
          const dummy = new THREE.Object3D();
          group.add(dummy);
        }

        // 2) Immagine (se presente): node.image o node.img
        const imgUrl = resolveImageURL(node.image || node.img);
        if (imgUrl) {
          const sprite = new THREE.Sprite(
            new THREE.SpriteMaterial({ transparent: true })
          );
          // dimensioni provvisorie finché la texture non è pronta
          sprite.scale.set(IMG_H, IMG_H, 1);
          // posiziona l’immagine sopra il testo
          sprite.position.set(0, IMG_H * 0.6, 0);
          group.add(sprite);

          loadTextureCached(
            imgUrl,
            (tex) => {
              sprite.material.map = tex;
              sprite.material.needsUpdate = true;
              const w = tex.image?.width || 1;
              const h = tex.image?.height || 1;
              const r = h / w;
              sprite.scale.set(IMG_H, IMG_H * r, 1);
            },
            () => {
              // se fallisce il load, togli lo sprite e lascia solo il testo
              group.remove(sprite);
            }
          );
        }

        return group;
      }

      function refreshNodeRenderer() {
        Graph.nodeThreeObject(buildNodeObject).nodeThreeObjectExtend(true);
      }

      // inizializza renderer nodi
      refreshNodeRenderer();

      // === Selezione e pannello ===
      function $(sel) { return document.querySelector(sel); }
      function selectOnly(id) {
        selectedIds = new Set(id ? [id] : []);
        updateEditor();
        refreshNodeRenderer();
      }
      function toggleSelection(id) {
        if (!id) return;
        if (selectedIds.has(id)) selectedIds.delete(id);
        else selectedIds.add(id);
        updateEditor();
        refreshNodeRenderer();
      }
      function getSingleSelectedId() {
        return selectedIds.size === 1 ? [...selectedIds][0] : null;
      }
      function updateEditor() {
        const panel = document.getElementById("editor");
        const selInfo = document.getElementById("selInfo");
        if (selectedIds.size !== 1) {
          panel.style.display = "none";
          selInfo.textContent = selectedIds.size ? `${selectedIds.size} nodi selezionati` : "";
          return;
        }
        const sid = getSingleSelectedId();
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) {
          panel.style.display = "none";
          selInfo.textContent = "";
          return;
        }
        panel.style.display = "block";
        selInfo.textContent = `Selezionato: ${n.name || n.id}`;
        $("#fTitle").value = n.name || "";
        $("#fAreas").value = (n.areas || []).join(", ");
        $("#fTags").value = (n.tags || []).join(", ");
        $("#fDesc").value = n.desc || "";
        renderFilesListFor(n);
      }
      function renderFilesListFor(n) {
        const list = $("#filesList");
        const files = n.files || [];
        if (!files.length) { list.innerHTML = ""; return; }
        list.innerHTML = files.map((file, i) => {
          const name = escapeHtml(file.name || "file");
          const size = file.size ? ` — ${Math.round(file.size/1024)} KB` : "";
          const thumb = file.isImage && file.url ? `<img class=\"thumb\" src=\"${escapeHtml(file.url)}\">` : "";
          return `<div class=\"file-row\"><div class=\"file-left\">${thumb}<div class=\"name\">• ${name}${size}</div></div><div class=\"remove\" data-idx=\"${i}\">Remove</div></div>`;
        }).join("");
      }

      // Calcolo cluster (grappoli) come componenti connesse
      function computeClusters(nodes, links) {
        const idSet = new Set(nodes.map((n) => n.id));
        const adj = new Map();
        for (const id of idSet) adj.set(id, new Set());
        for (const l of links || []) {
          const s = typeof l.source === 'object' ? l.source?.id : l.source;
          const t = typeof l.target === 'object' ? l.target?.id : l.target;
          if (s == null || t == null) continue;
          if (!adj.has(s)) adj.set(s, new Set());
          if (!adj.has(t)) adj.set(t, new Set());
          adj.get(s).add(t);
          adj.get(t).add(s);
        }
        const comp = new Map();
        let c = 0;
        for (const id of idSet) {
          if (comp.has(id)) continue;
          const stack = [id];
          comp.set(id, c);
          while (stack.length) {
            const u = stack.pop();
            for (const v of adj.get(u) || []) {
              if (!comp.has(v)) {
                comp.set(v, c);
                stack.push(v);
              }
            }
          }
          c++;
        }
        return comp; // Map id -> clusterIndex
      }

      // Normalizza i dati: link sempre come id, copia pulita dei campi
      function normalizeData(d) {
        const nodes = (d?.nodes || []).map((n) => ({
          id: n.id,
          name: n.name || "",
          group: n.group || "",
          type: n.type || "",
          areas: Array.isArray(n.areas) ? [...n.areas] : [],
          tags: Array.isArray(n.tags) ? [...n.tags] : [],
          desc: n.desc || "",
          image: n.image || null,
          files: (n.files || []).map((f) => ({
            name: f.name,
            size: f.size,
            isImage: !!f.isImage,
            isPDF: !!f.isPDF,
            path: f.path || null,
            url: f.url || null,
          })),
        }));
        const idSet = new Set(nodes.map((n) => n.id));
        const links = (d?.links || [])
          .map((l) => {
            const s = typeof l.source === "object" ? l.source?.id : l.source;
            const t = typeof l.target === "object" ? l.target?.id : l.target;
            return { source: s, target: t, dashed: !!l.dashed };
          })
          .filter((l) => idSet.has(l.source) && idSet.has(l.target));
        return { nodes, links };
      }

      // Wrapper per impostare i dati e assegnare i cluster (senza mutare currentData)
      function setGraphData(data) {
        const clean = normalizeData(data || { nodes: [], links: [] });
        try {
          const comp = computeClusters(clean.nodes || [], clean.links || []);
          (clean.nodes || []).forEach((n) => {
            n.__cluster = comp.get(n.id) ?? 0;
          });
        } catch (e) {
          (clean.nodes || []).forEach((n) => (n.__cluster = 0));
        }
        Graph.graphData(clean);
        refreshNodeRenderer();
        setTimeout(() => Graph.zoomToFit(600, 60), 300);
      }

      // —— Palette colore deterministica (by group) ——
      const PALETTE = [
        "#7aa2f7",
        "#9ece6a",
        "#f7768e",
        "#bb9af7",
        "#e0af68",
        "#2ac3de",
        "#c0caf5",
        "#73daca",
        "#7dcfff",
        "#f6bd60",
        "#ee6c4d",
        "#84a59d",
        "#f28482",
        "#82aaff",
        "#ffd166",
      ];
      function groupColor(g) {
        if (!g) return "#cbd5e1";
        let h = 0;
        for (let i = 0; i < g.length; i++) h = (h * 31 + g.charCodeAt(i)) >>> 0;
        return PALETTE[h % PALETTE.length];
      }

      // —— Tooltip ricco su hover ——
      function showTip(node) {
        const tip = document.getElementById("tooltip");
        if (!node) {
          tip.style.display = "none";
          window.onmousemove = null;
          return;
        }
        const tags = (node.tags || []).join(", ");
        const areas = (node.areas || []).join(", ");
        const fields = [
          node.type ? `<div><b>Type:</b> ${escapeHtml(node.type)}</div>` : "",
          areas ? `<div><b>Areas:</b> ${escapeHtml(areas)}</div>` : "",
          tags ? `<div><b>Tags:</b> ${escapeHtml(tags)}</div>` : "",
          node.group
            ? `<div><b>Group:</b> ${escapeHtml(node.group)}</div>`
            : "",
        ]
          .filter(Boolean)
          .join("");
        const imgHtml =
          node.image || node.img
            ? `<div style="margin-top:6px">
               <img src="${escapeHtml(resolveImageURL(node.image || node.img))}"
                    style="max-width:240px;max-height:160px;display:block;border:1px solid rgba(255,255,255,.2)"/>
             </div>`
            : "";
        tip.innerHTML = `
          <div style="font-weight:700">${escapeHtml(
            node.name || node.id || ""
          )}</div>
          ${fields}
          ${
            node.desc
              ? `<div style="margin-top:8px; white-space:pre-wrap">${escapeHtml(
                  node.desc
                )}</div>`
              : ""
          }
          ${imgHtml}
        `;
        tip.style.display = "block";
        window.onmousemove = (e) => {
          tip.style.left = e.clientX + 12 + "px";
          tip.style.top = e.clientY + 12 + "px";
        };
      }
      function escapeHtml(s) {
        if (!s) return "";
        return ("" + s).replace(
          /[&<>\"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }

      // —— Toolbar actions ——
      document.getElementById("btnFit").onclick = () => {
        Graph.zoomToFit(600, 60);
      };
      document.getElementById("btnToggleSize").onclick = () => {
        textScale = textScale >= 1.6 ? 0.8 : textScale + 0.2;
        refreshNodeRenderer();
      };

      document.getElementById("colorBy").onchange = (e) => {
        colorMode = e.target.value;
        refreshNodeRenderer();
      };

      // Toolbar extra
      document.getElementById("btnConnect").onclick = () => connectSelectedNodes();
      document.getElementById("btnSpawn").onclick = () => spawnChildFromSelected();
      document.getElementById("btnDelete").onclick = () => deleteSelected();
      document.getElementById("btnUndo").onclick = () => undo();
      document.getElementById("btnRedo").onclick = () => redo();
      document.getElementById("btnOpenFolder").onclick = async () => {
        try { await openProjectFromFolder(); } catch (e) { alert(e.message || e); }
      };
      document.getElementById("btnSave").onclick = async () => {
        try { await saveProjectSmart(); } catch (e) { alert(e.message || e); }
      };

      // Rimosso il caricamento rapido di graphdata.json

      document.getElementById("file").onchange = async (e) => {
        const fl = e.target.files[0];
        if (!fl) return;
        const text = await fl.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch (err) {
          return alert("JSON non valido");
        }
        // Accetta sia graphData diretto, sia Threadscape project.json (converte al volo)
        if (isGraphData(data)) {
          pushHistory();
          currentData = normalizeData(data);
          setGraphData(currentData);
        } else if (isThreadscape(data)) {
          pushHistory();
          currentData = normalizeData(convertProjectToGraphData(data));
          setGraphData(currentData);
        } else {
          return alert("Formato non riconosciuto");
        }
        selectedIds = new Set();
        updateEditor();
      };

      function isGraphData(d) {
        return (
          d &&
          Array.isArray(d.nodes) &&
          Array.isArray(d.links) &&
          (d.nodes.length === 0 || d.nodes[0].id !== undefined) &&
          (d.links.length === 0 ||
            ("source" in d.links[0] && "target" in d.links[0]))
        );
      }
      function isThreadscape(d) {
        return (
          d && d.version && Array.isArray(d.nodes) && Array.isArray(d.edges)
        );
      }
      function convertProjectToGraphData(project) {
        const nodes = (project.nodes || []).map((n) => {
          const d = n.data || {};
          const image = pickNodeImageFromFiles(d.files);

          return {
            id: n.id,
            name: d.title || n.id,
            // main area / type non usati in questa vista
            group: "",
            type: "",
            areas: d.areas || [],
            tags: d.tags || [],
            desc: d.desc || "",
            image,
            files: (d.files || []).map((f) => ({
              name: f.name,
              size: f.size,
              isImage: !!f.isImage,
              isPDF: !!f.isPDF,
              path: f.path || null,
              url: f.url || (f.path ? resolveImageURL(f.path) : null),
            })),
          };
        });

        const seen = new Set();
        const links = (project.edges || [])
          .map((e) => {
            const s = e.s,
              t = e.t;
            const key = [s, t].sort().join("||"); // nondirezionale + dedup
            if (seen.has(key)) return null;
            seen.add(key);
            return { source: s, target: t, dashed: !!e.dashed };
          })
          .filter(Boolean);

        return { nodes, links };
      }

      // === Undo/redo helper ===
      function uid() { return "n" + Math.random().toString(36).slice(2, 9); }
      function deepClone(x) { return JSON.parse(JSON.stringify(x)); }
      function pushHistory() {
        history.undo.push(deepClone(normalizeData(currentData)));
        if (history.undo.length > history.limit) history.undo.shift();
        history.redo.length = 0;
      }
      function undo() {
        if (!history.undo.length) return;
        history.redo.push(deepClone(normalizeData(currentData)));
        currentData = history.undo.pop();
        setGraphData(currentData);
        selectOnly(null);
      }
      function redo() {
        if (!history.redo.length) return;
        history.undo.push(deepClone(normalizeData(currentData)));
        currentData = history.redo.pop();
        setGraphData(currentData);
        selectOnly(null);
      }

      // === Azioni sui nodi ===
      function spawnChildFromSelected() {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const parent = currentData.nodes.find((n) => n.id === sid);
        if (!parent) return;
        pushHistory();
        const id = uid();
        const child = {
          id,
          name: "Nuovo nodo",
          areas: [...(parent.areas || [])],
          tags: [],
          desc: "",
          files: [],
        };
        currentData.nodes.push(child);
        currentData.links.push({ source: parent.id, target: id });
        setGraphData(currentData);
        selectOnly(id);
      }
      function deleteSelected() {
        if (!selectedIds.size) return;
        pushHistory();
        const del = new Set(selectedIds);
        currentData.nodes = currentData.nodes.filter((n) => !del.has(n.id));
        currentData.links = currentData.links.filter((l) => {
          const s = typeof l.source === 'object' ? l.source?.id : l.source;
          const t = typeof l.target === 'object' ? l.target?.id : l.target;
          return !del.has(s) && !del.has(t);
        });
        setGraphData(currentData);
        selectOnly(null);
      }

      function connectSelectedNodes() {
        if (selectedIds.size !== 2) return;
        const [a, b] = [...selectedIds];
        if (a === b) return;
        // evita duplicati (nondirezionale)
        const key = (x, y) => [x, y].sort().join('||');
        const existing = new Set((currentData.links || []).map(l => key(
          typeof l.source === 'object' ? l.source?.id : l.source,
          typeof l.target === 'object' ? l.target?.id : l.target
        )));
        const k = key(a, b);
        if (existing.has(k)) return;
        pushHistory();
        currentData.links.push({ source: a, target: b });
        setGraphData(currentData);
      }

      // === Editor bindings ===
      document.getElementById('fTitle').addEventListener('input', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        n.name = document.getElementById('fTitle').value.trim(); refreshNodeRenderer();
      });
      document.getElementById('fAreas').addEventListener('change', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        const raw = document.getElementById('fAreas').value || '';
        n.areas = raw.split(/,\s*/).filter(Boolean); refreshNodeRenderer();
      });
      document.getElementById('fTags').addEventListener('change', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        const raw = document.getElementById('fTags').value || '';
        n.tags = raw.split(/,\s*/).filter(Boolean);
      });
      document.getElementById('fDesc').addEventListener('change', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        n.desc = document.getElementById('fDesc').value;
      });

      document.getElementById('btnAddFiles').addEventListener('click', () => document.getElementById('fFiles').click());
      document.getElementById('fFiles').addEventListener('change', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        const inp = document.getElementById('fFiles');
        const fls = Array.from(inp.files || []);
        n.files = n.files || [];
        for (const f of fls) {
          const entry = { name: f.name, size: f.size, isImage: /^image\//i.test(f.type), isPDF: /pdf$/i.test(f.type) || /\.pdf$/i.test(f.name), path: 'assets/' + f.name, url: URL.createObjectURL(f), __file: f };
          n.files.push(entry);
        }
        const firstImg = (n.files || []).find(x=>x.isImage);
        n.image = firstImg ? firstImg.url : n.image;
        renderFilesListFor(n);
        refreshNodeRenderer();
        inp.value = '';
      });
      document.getElementById('filesList').addEventListener('click', (e) => {
        const rm = e.target.closest('.remove'); if (!rm) return;
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        const idx = Number(rm.getAttribute('data-idx'));
        if (!Number.isFinite(idx)) return;
        n.files.splice(idx, 1);
        const firstImg = (n.files || []).find(x=>x.isImage);
        n.image = firstImg ? (firstImg.url || resolveImageURL(firstImg.path)) : null;
        renderFilesListFor(n);
        refreshNodeRenderer();
      });

      // === File System Access: open/save ===
      const projectCtx = { dirHandle: null };
      async function openProjectFromFolder() {
        if (!('showDirectoryPicker' in window)) throw new Error('Il browser non supporta l\'apertura cartelle');
        const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
        const found = await findProjectJson(dir);
        if (!found) throw new Error('project.json non trovato nella cartella selezionata');
        const { root, fileHandle } = found;
        const file = await fileHandle.getFile();
        const text = await file.text();
        const project = JSON.parse(text);
        if (!isThreadscape(project)) throw new Error('project.json non è nel formato Threadscape');
        projectCtx.dirHandle = root;
        pushHistory();
        currentData = normalizeData(convertProjectToGraphData(project));
        await attachObjectURLsFromDir(root, currentData);
        setGraphData(currentData);
        selectOnly(null);
      }

      // Cerca ricorsivamente project.json partendo dalla cartella scelta
      async function findProjectJson(root, depth = 0, maxDepth = 4) {
        if (!root || depth > maxDepth) return null;
        // prova nella root corrente
        try {
          const fh = await root.getFileHandle('project.json', { create: false });
          if (fh) return { root, fileHandle: fh };
        } catch {}
        // altrimenti scansiona sottocartelle
        try {
          for await (const [name, handle] of root.entries()) {
            if (handle.kind === 'directory') {
              const found = await findProjectJson(handle, depth + 1, maxDepth);
              if (found) return found;
            }
          }
        } catch {}
        return null;
      }
      async function attachObjectURLsFromDir(dir, data) {
        for (const n of data.nodes || []) {
          for (const f of n.files || []) {
            if (f.path && !f.url) {
              try { const file = await readFileByPath(dir, f.path); if (file) f.url = URL.createObjectURL(file); } catch {}
            }
          }
          const firstImg = (n.files || []).find(x=>x.isImage);
          if (firstImg && firstImg.url) n.image = firstImg.url;
        }
      }
      async function saveProjectSmart() {
        if (projectCtx.dirHandle) {
          await saveProjectToDir(projectCtx.dirHandle);
          alert('Salvato');
        } else if ('showDirectoryPicker' in window) {
          const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
          projectCtx.dirHandle = dir;
          await saveProjectToDir(dir);
          alert('Salvato in nuova cartella');
        } else {
          const blob = new Blob([JSON.stringify(buildProjectObject(), null, 2)], { type: 'application/json' });
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'project.json'; a.click();
        }
      }
      function buildProjectObject() {
        const nodes = (currentData.nodes || []).map((n) => {
          const files = (n.files || []).map((f) => ({ name: f.name, size: f.size, isImage: !!f.isImage, isPDF: !!f.isPDF, path: f.path || null }));
          // Esporta senza type e mainArea
          return { id: n.id, data: { title: n.name || n.id, type: '', mainArea: null, areas: n.areas || [], tags: n.tags || [], desc: n.desc || '', files } };
        });
        const edges = (currentData.links || []).map((l) => ({ s: (typeof l.source==='object'?l.source?.id:l.source), t: (typeof l.target==='object'?l.target?.id:l.target), dashed: !!l.dashed }));
        return { version: 6, nodes, edges };
      }
      async function writeFileByPath(root, relPath, blob) {
        const parts = relPath.split('/').filter(Boolean);
        let dir = root;
        for (let i = 0; i < parts.length - 1; i++) { dir = await dir.getDirectoryHandle(parts[i], { create: true }); }
        const fileHandle = await dir.getFileHandle(parts[parts.length - 1], { create: true });
        const w = await fileHandle.createWritable(); await w.write(blob); await w.close();
      }
      async function readFileByPath(root, relPath) {
        const parts = relPath.split('/').filter(Boolean);
        let dir = root;
        for (let i = 0; i < parts.length - 1; i++) { dir = await dir.getDirectoryHandle(parts[i], { create: false }); }
        const fileHandle = await dir.getFileHandle(parts[parts.length - 1], { create: false });
        return await fileHandle.getFile();
      }
      async function saveProjectToDir(dir) {
        for (const n of currentData.nodes || []) {
          for (const f of n.files || []) {
            if (f.__file) {
              const rel = f.path || ('assets/' + f.__file.name);
              await writeFileByPath(dir, rel, f.__file);
              f.path = rel;
            }
          }
        }
        const project = buildProjectObject();
        const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
        await writeFileByPath(dir, 'project.json', blob);
      }

      // Shortcut da tastiera (con guardie per i campi di testo)
      window.addEventListener('keydown', (e) => {
        const isMac = navigator.platform.toUpperCase().includes('MAC');
        const mod = isMac ? e.metaKey : e.ctrlKey;
        const t = e.target;
        const tag = (t && t.tagName ? t.tagName : '').toLowerCase();
        const type = (t && t.type ? String(t.type).toLowerCase() : '');
        const isEditable = (t && t.isContentEditable) || tag === 'textarea' || tag === 'input';
        const isTyping = isEditable && !['button','checkbox','radio','file','submit','reset'].includes(type);

        // Lascia all'input i tasti Undo/Redo e Canc/Backspace
        if (isTyping) {
          if (mod && e.key.toLowerCase() === 'z') return; // undo/redo nativo del campo
          if (!mod && (e.key === 'Delete' || e.key === 'Backspace')) return; // non eliminare nodi se sto scrivendo
          if (!mod && e.key.toLowerCase() === 'c') return; // non catturare 'c' mentre scrivo
        }

        if (mod && e.key.toLowerCase() === 'z') { e.preventDefault(); if (e.shiftKey) redo(); else undo(); }
        else if (mod && e.key.toLowerCase() === 's') { e.preventDefault(); saveProjectSmart(); }
        else if (mod && e.key.toLowerCase() === 'o') { e.preventDefault(); openProjectFromFolder(); }
        else if (e.key === 'Delete' || e.key === 'Backspace') { if (selectedIds.size) { e.preventDefault(); deleteSelected(); } }
        else if (!mod && e.key.toLowerCase() === 'c') { e.preventDefault(); connectSelectedNodes(); }
      });
    </script>
  </body>
</html>

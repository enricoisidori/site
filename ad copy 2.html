<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DAG Editor — TouchDesigner style</title>
    <style>
      :root {
        --bg: #0e0e0e;
        --panel: #151515;
        --ink: #ffffff;
        --muted: #bdbdbd;
        --line: #2a2a2a;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: #eee;
        font: 14px/1.4 system-ui;
        -webkit-tap-highlight-color: transparent;
      }

      header {
        padding: 8px;
        border-bottom: 1px solid #333;
        display: flex;
        gap: 10px;
        align-items: center;
      }
      button {
        background: #111;
        color: #eee;
        border: 1px solid #444;
        padding: 6px 10px;
        border-radius: 6px;
        cursor: pointer;
      }
      button:focus,
      button:focus-visible {
        outline: none;
        box-shadow: none;
      }
      .app {
        display: grid;
        grid-template-columns: 1fr 380px;
        grid-template-rows: 50px 1fr;
        height: 100vh;
      }

      #stage {
        position: relative;
        overflow: hidden;
        user-select: none;
        background: #0e0e0e;
        background-image: linear-gradient(#111 1px, transparent 1px),
          linear-gradient(90deg, #111 1px, transparent 1px);
        background-size: 24px 24px, 24px 24px;
        background-position: 0 0, 0 0;
        cursor: default;
      }
      svg#edges {
        position: absolute;
        inset: 0;
        z-index: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .node {
        position: absolute;
        width: 320px;
        max-width: 400px;
        min-width: 260px;
        border: 1px solid #444;
        border-radius: 8px;
        background: var(--panel);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
        cursor: grab;
        z-index: 1;
        transform-origin: top left;
      }
      .node.dragging {
        cursor: grabbing;
      }
      .node.selected {
        outline: 2px solid #fff;
      }

      .titlebar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: #1b1b1b;
        border-bottom: 1px solid #2a2a2a;
        padding: 6px 8px;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
      }
      .title {
        font-weight: 700;
        color: #fff;
        min-height: 1em;
      }

      .body {
        padding: 8px;
      }
      .meta {
        color: var(--muted);
        font-size: 12px;
        font-family: inherit;
      }
      .divider {
        height: 1px;
        background: #2a2a2a;
        margin: 6px 0;
      }
      .kv {
        display: grid;
        grid-template-columns: 110px 1fr;
        gap: 4px;
        font-size: 12px;
      }
      .kv div:nth-child(odd) {
        color: #bbb;
      }

      .desc {
        margin-top: 6px;
        font-size: 12px;
        white-space: pre-wrap;
        font-family: inherit;
      }
      .descTitle {
        margin-top: 8px;
        font-size: 12px;
        color: #bbb;
      }
      .tags {
        margin-top: 6px;
      }
      .badge {
        display: inline-block;
        border: 1px solid #444;
        border-radius: 999px;
        padding: 2px 6px;
        margin: 2px 6px 0 0;
        font-size: 12px;
      }

      .links {
        margin-top: 8px;
        font-size: 12px;
        font-family: inherit;
      }
      .links a {
        color: #fff;
        text-decoration: underline;
        display: inline-block;
        margin: 2px 10px 0 0;
      }

      .images {
        margin-top: 8px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .images img {
        display: block;
        width: 100%;
        height: auto;
        border: 1px solid #444;
        border-radius: 6px;
        pointer-events: none;
        -webkit-user-drag: none;
        user-drag: none;
      }
      .attachments {
        margin-top: 8px;
        font-size: 12px;
      }
      .attachments a {
        color: #fff;
        text-decoration: underline;
        margin-right: 10px;
      }

      /* bigger hit-area for handles; visual remains small */
      .handle {
        position: absolute;
        width: 24px;
        height: 24px;
        pointer-events: auto;
        cursor: pointer;
      }
      .out {
        right: -15px;
        top: 50%;
        transform: translateY(-50%);
      }
      .in {
        left: -15px;
        top: 50%;
        transform: translateY(-50%);
      }
      .out::after {
        content: "";
        position: absolute;
        width: 14px;
        height: 14px;
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
        background: #fff;
        border: 1px solid #000;
        border-radius: 50%;
      }
      .in::after {
        content: "";
        position: absolute;
        width: 14px;
        height: 14px;
        left: 5px;
        top: 50%;
        transform: translateY(-50%);
        background: #fff;
        border: 1px solid #000;
        clip-path: polygon(0% 0%, 100% 50%, 0% 100%);
      }

      /* Edges — no glow */
      .edge-visible {
        cursor: pointer;
        stroke: #9a9a9a;
        stroke-width: 2;
        fill: none;
        stroke-linecap: butt;
        filter: none;
      }
      .edge-visible.selected {
        stroke: #ffffff;
        stroke-width: 3;
        filter: none;
      }
      .edge-visible.weak {
        stroke: #ffffff;
        stroke-opacity: 0.4;
        stroke-dasharray: 10 6;
        stroke-linecap: round;
        stroke-width: 1.5;
      }
      .edge-visible.weak.selected {
        stroke: #ffffff;
        stroke-opacity: 1;
        stroke-dasharray: 10 6;
        stroke-linecap: round;
        stroke-width: 2.5;
      }
      .edge-hit {
        stroke: #000;
        stroke-opacity: 0;
        stroke-width: 16;
        fill: none;
        cursor: pointer;
      }

      .marquee {
        position: absolute;
        border: 1px solid #bbb;
        background: rgba(255, 255, 255, 0.06);
        pointer-events: none;
        z-index: 2;
      }

      aside {
        background: #121212;
        border-left: 1px solid #333;
        padding: 10px;
        overflow: auto;
      }
      h3#panelTitle {
        margin: 0.6rem 0 0.3rem;
        font-size: 12px;
        font-weight: 400;
        text-transform: none;
        color: #bbb;
        letter-spacing: 0.02em;
      }
      label {
        display: block;
        font-size: 12px;
        margin-top: 12px;
      }
      input[type="text"],
      input[type="date"],
      textarea {
        width: 100%;
        background: #0d0d0d;
        border: 1px solid #444;
        border-radius: 6px;
        color: #eee;
        padding: 6px;
        font-family: inherit;
        margin-top: 6px;
      }
      input:focus,
      input:focus-visible,
      textarea:focus,
      textarea:focus-visible {
        outline: none;
        box-shadow: none;
        border-color: #555;
      }
      textarea {
        min-height: 140px;
        resize: vertical;
      }
      .muted {
        color: #bbb;
      }

      .file-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        font-size: 12px;
        padding: 6px 0;
        border-bottom: 1px solid #333;
      }
      .file-left {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }
      .thumb {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 1px solid #333;
        object-fit: cover;
        display: block;
      }
      .file-row .name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 220px;
      }
      .file-row .remove {
        cursor: pointer;
        text-decoration: underline;
      }

      .checkboxRow {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
      }
      .checkboxRow input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: #e6e6e6;
        transform: scale(1.1);
        background: #0d0d0d;
        border: 1px solid #444;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header style="grid-column: 1/3">
        <button id="btnAdd">+ New node</button>
        <button id="btnAuto">Auto layout</button>
        <button id="btnOpen">Open</button>
        <button id="btnSave">Save</button>
        <button id="btnUndo">Undo</button>
        <button id="btnRedo">Redo</button>
        <button id="btnDel">Delete selection</button>
        <button id="btnFit">Fit view (0)</button>
        <span id="status" class="muted" style="margin-left: 8px"></span>
      </header>

      <div id="stage">
        <svg id="edges" preserveAspectRatio="none">
          <g id="edgeLayer"></g>
          <g id="ghostLayer"></g>
        </svg>
      </div>

      <aside>
        <h3 id="panelTitle">Node properties</h3>

        <div id="nodeForm">
          <form onsubmit="return false;">
            <label>Date <input id="fDate" type="date" /></label>
            <label
              >Title
              <input
                id="fTitle"
                type="text"
                placeholder="(optional, spaces allowed)"
            /></label>
            <label>Object <input id="fObject" type="text" /></label>
            <label>Action <input id="fAction" type="text" /></label>
            <label>Main area <input id="fMainArea" type="text" /></label>
            <label
              >Areas
              <input
                id="fAreas"
                type="text"
                placeholder="comma or newline separated"
            /></label>
            <label
              >Description
              <textarea id="fDesc" placeholder="free text"></textarea>
            </label>
            <label
              >Tags
              <input
                id="fTags"
                type="text"
                placeholder="comma or newline separated"
            /></label>
            <label
              >Links
              <textarea
                id="fLinks"
                placeholder="one per line or comma separated"
              ></textarea>
            </label>

            <input id="fFiles" type="file" multiple style="display: none" />
            <div
              style="
                display: flex;
                gap: 8px;
                align-items: center;
                margin-top: 10px;
              "
            >
              <button id="btnChoose" type="button">Choose files</button>
              <span id="selInfo" class="muted">No selection</span>
            </div>
            <div id="filesList" class="muted" style="margin-top: 6px"></div>
          </form>
        </div>

        <div id="edgeForm" style="display: none">
          <div class="muted" style="font-size: 12px; margin-bottom: 6px">
            From: <span id="eFrom">—</span> → To: <span id="eTo">—</span>
          </div>
          <label class="checkboxRow">
            <input id="eDashed" type="checkbox" /> Weak (dashed)
          </label>
        </div>

        <input
          id="openFile"
          type="file"
          accept="application/json"
          style="display: none"
        />
      </aside>
    </div>

    <script>
      (() => {
        const GRID = 24,
          NODE_W = 320,
          NODE_H = 180,
          HGAP = 160,
          VGAP = 40,
          MIN_LAYER_GAP = 24;
        const IMG_MAX_SIDE = 1500,
          IMG_TARGET_BYTES = 500 * 1024;
        const CLICK_THRESHOLD = 5;

        const projectCtx = { mode: null, dirHandle: null };

        const history = {
          undo: [],
          redo: [],
          limit: 80,
          lock: false,
          debounce: null,
        };
        const snap = () => ({
          nodes: structuredClone(state.nodes),
          edges: structuredClone(state.edges),
          selNodes: [...state.selNodes],
          selEdges: [...state.selEdges],
          pan: { ...state.pan },
          zoom: state.zoom,
        });
        function pushHistory() {
          if (history.lock) return;
          history.undo.push(snap());
          if (history.undo.length > history.limit) history.undo.shift();
          history.redo.length = 0;
        }
        const scheduleHistory = () => {
          clearTimeout(history.debounce);
          history.debounce = setTimeout(pushHistory, 400);
        };
        function applySnapshot(s) {
          history.lock = true;
          document.querySelectorAll(".node").forEach((n) => n.remove());
          state.nodes = structuredClone(s.nodes || []);
          state.edges = structuredClone(s.edges || []);
          state.selNodes = new Set(s.selNodes || []);
          state.selEdges = new Set(s.selEdges || []);
          state.pan = s.pan ? { ...s.pan } : { x: 0, y: 0 };
          state.zoom = s.zoom ?? 1;

          state.nodes.forEach((n) => {
            mountNode(n);
            measure(n);
            positionNode(n);
            populate(n);
          });

          ensureSVGSize();
          updateGrid();
          rebuildEdgesIndex();
          requestFullEdgeRedraw();
          scheduleRender();

          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          history.lock = false;
        }
        function undo() {
          if (!history.undo.length) return;
          const cur = snap();
          const prev = history.undo.pop();
          history.redo.push(cur);
          applySnapshot(prev);
          setStatus("Undone");
        }
        function redo() {
          if (!history.redo.length) return;
          const cur = snap();
          const next = history.redo.pop();
          history.undo.push(cur);
          applySnapshot(next);
          setStatus("Redone");
        }

        const state = {
          nodes: [],
          edges: [],
          selNodes: new Set(),
          selEdges: new Set(),
          zoom: 1,
          pan: { x: 0, y: 0 },

          press: null, // handle press (edge) {side,sources,primary,startX,startY,moved}
          dragLink: null, // ghost {active,from,sources,primary,x,y}
          activeDrag: null, // node drag {ids:[...], offsets:{id:{dx,dy}} }
          spaceDown: false,
          marquee: null,
          ignoreNextStageClick: false,

          edgeGroups: [], // <g> refs ordered by index
          edgesByNode: new Map(), // nodeId -> Set(edgeIndex)
          dirtyEdgeIdx: new Set(),
          needFullEdgeRedraw: true,
          rafPending: false,
        };

        const stage = $("#stage"),
          edgesSVG = $("#edges"),
          edgeLayer = $("#edgeLayer"),
          ghostLayer = $("#ghostLayer"),
          status = $("#status");
        const f = {
          date: $("#fDate"),
          title: $("#fTitle"),
          object: $("#fObject"),
          action: $("#fAction"),
          main: $("#fMainArea"),
          areas: $("#fAreas"),
          tags: $("#fTags"),
          desc: $("#fDesc"),
          links: $("#fLinks"),
          files: $("#fFiles"),
          filesList: $("#filesList"),
          selInfo: $("#selInfo"),
          btnChoose: $("#btnChoose"),
          openFile: $("#openFile"),
          nodeForm: $("#nodeForm"),
          edgeForm: $("#edgeForm"),
          eFrom: $("#eFrom"),
          eTo: $("#eTo"),
          eDashed: $("#eDashed"),
          panelTitle: $("#panelTitle"),
        };

        function $(s) {
          return document.querySelector(s);
        }
        const uid = () => "n" + Math.random().toString(36).slice(2, 9);
        const setStatus = (m) => (status.textContent = m || "");
        const esc = (s) =>
          (s ?? "").replace(
            /[&<>"']/g,
            (c) =>
              ({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
              }[c])
          );
        function splitList(str) {
          return (str || "")
            .split(/[\n,;]+|,\s*/)
            .map((s) => s.trim())
            .filter(Boolean);
        }
        function normalizeURL(s) {
          if (!s) return null;
          let u = s.trim();
          if (!/^https?:\/\//i.test(u)) u = "https://" + u;
          try {
            new URL(u);
            return u;
          } catch {
            return null;
          }
        }
        function bytes(b) {
          if (!Number.isFinite(b)) return "";
          const k = 1024,
            u = ["B", "KB", "MB", "GB"];
          let i = 0;
          while (b >= k && i < u.length - 1) {
            b /= k;
            i++;
          }
          return b.toFixed(b < 10 && i > 0 ? 1 : 0) + " " + u[i];
        }
        function todayYMD() {
          const d = new Date();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${d.getFullYear()}-${mm}-${dd}`;
        }
        function formatDateIT(ymd) {
          if (!ymd) return "";
          const [y, m, d] = ymd.split("-");
          return y && m && d ? `${d}/${m}/${y}` : ymd;
        }

        function toWorld(cx, cy) {
          const r = stage.getBoundingClientRect();
          return {
            x: (cx - r.left - state.pan.x) / state.zoom,
            y: (cy - r.top - state.pan.y) / state.zoom,
          };
        }
        function fromWorld(x, y) {
          return {
            x: x * state.zoom + state.pan.x,
            y: y * state.zoom + state.pan.y,
          };
        }

        function ensureSVGSize() {
          const r = stage.getBoundingClientRect();
          const w = Math.max(1, Math.round(r.width)),
            h = Math.max(1, Math.round(r.height));
          edgesSVG.setAttribute("width", w);
          edgesSVG.setAttribute("height", h);
          edgesSVG.setAttribute(
            "viewBox",
            `${-state.pan.x / state.zoom} ${-state.pan.y / state.zoom} ${
              w / state.zoom
            } ${h / state.zoom}`
          );
        }
        window.addEventListener("resize", () => {
          ensureSVGSize();
          updateGrid();
          requestFullEdgeRedraw();
          scheduleRender();
        });
        ensureSVGSize();

        function updateGrid() {
          const sizeX = GRID * state.zoom,
            sizeY = GRID * state.zoom;
          const posX = state.pan.x % sizeX,
            posY = state.pan.y % sizeY;
          stage.style.backgroundSize = `${sizeX}px ${sizeY}px, ${sizeX}px ${sizeY}px`;
          stage.style.backgroundPosition = `${posX}px ${posY}px, ${posX}px ${posY}px`;
        }

        function emptyData() {
          return {
            date: todayYMD(),
            title: "",
            object: "",
            action: "",
            mainArea: "",
            areas: [],
            tags: [],
            desc: "",
            links: [],
            files: [],
          };
        }
        function getNodeById(id) {
          return state.nodes.find((n) => n.id === id) || null;
        }
        function getEdgeByIndex(i) {
          return state.edges[i] || null;
        }

        function addNodeAt(x, y, initialData = null) {
          pushHistory();
          const id = uid();
          const node = {
            id,
            x,
            y,
            w: 320,
            h: 180,
            data: initialData
              ? { ...emptyData(), ...initialData }
              : emptyData(),
          };
          state.nodes.push(node);
          mountNode(node);
          measure(node);
          positionNode(node);
          populate(node);
          selectOnlyNodes([id]);
          rebuildEdgesIndex();
          requestFullEdgeRedraw();
          scheduleRender();
          return id;
        }
        function addNode() {
          const i = state.nodes.length;
          return addNodeAt(80 + i * 40, 80 + i * 30);
        }

        function mountNode(node) {
          const el = document.createElement("div");
          el.className = "node";
          el.id = node.id;
          el.innerHTML = `
            <div class="handle in" data-role="in" title="Input"></div>
            <div class="handle out" data-role="out" title="Output / Create child"></div>
            <div class="titlebar"><div class="title"></div></div>
            <div class="body">
              <div class="meta"><span class="date"></span></div>
              <div class="divider"></div>
              <div class="kv">
                <div>Object</div><div class="object"></div>
                <div>Action</div><div class="action"></div>
                <div>Main area</div><div class="mainArea"></div>
                <div>Areas</div><div class="areas"></div>
              </div>
              <div class="descBlock">
                <div class="descTitle" style="display:none">Description</div>
                <div class="desc"></div>
              </div>
              <div class="tags"></div>
              <div class="links"></div>
              <div class="images"></div>
              <div class="attachments"></div>
            </div>`;
          stage.appendChild(el);

          // Node drag start (single listener per node)
          el.addEventListener("mousedown", (e) => {
            const role = e.target.getAttribute("data-role");
            if (role) return;
            const nodeId = node.id;
            // selection logic
            if (node.group && !e.shiftKey) {
              const groupNodes = state.nodes
                .filter((n) => n.group === node.group)
                .map((n) => n.id);
              selectOnlyNodes(groupNodes);
            } else {
              if (e.shiftKey) {
                toggleNodeSelection(nodeId);
              } else if (!state.selNodes.has(nodeId)) {
                selectOnlyNodes([nodeId]);
              }
            }
            clearEdgeSelection();
            updateSidebarSelectionLabel();
            refreshSidebarForms();

            // prepare drag
            const cur = toWorld(e.clientX, e.clientY);
            const ids =
              state.selNodes.size > 1 ? [...state.selNodes] : [nodeId];
            const offsets = {};
            ids.forEach((id) => {
              const n = getNodeById(id);
              offsets[id] = { dx: n.x - cur.x, dy: n.y - cur.y };
            });
            state.activeDrag = { ids, offsets, measured: false };
            el.classList.add("dragging");
            pushHistory();
          });

          // Handle presses (edge gestures) – only mousedown; move/up are global
          const inEl = el.querySelector(".in");
          const outEl = el.querySelector(".out");
          const handleDown = (side) => (e) => {
            e.stopPropagation();
            const sources =
              state.selNodes.has(node.id) && state.selNodes.size > 1
                ? [...state.selNodes]
                : [node.id];
            state.press = {
              side,
              sources,
              primary: node.id,
              startX: e.clientX,
              startY: e.clientY,
              moved: false,
            };
          };
          inEl.addEventListener("mousedown", handleDown("in"));
          outEl.addEventListener("mousedown", handleDown("out"));
        }

        function positionNode(node) {
          const el = $("#" + node.id);
          const p = fromWorld(node.x, node.y);
          el.style.transform = `translate(${p.x}px,${p.y}px) scale(${state.zoom})`;
        }
        function measure(node) {
          const el = $("#" + node.id);
          node.w = el.offsetWidth;
          node.h = el.offsetHeight;
        }
        function populate(node) {
          const el = $("#" + node.id);
          if (!el) return;
          const d = node.data;
          const tb = el.querySelector(".titlebar");
          const hasTitle = !!(d.title && d.title.trim());
          tb.style.display = hasTitle ? "flex" : "none";
          el.querySelector(".title").textContent = hasTitle ? d.title : "";
          el.querySelector(".date").textContent = formatDateIT(d.date) || "";
          el.querySelector(".object").textContent = d.object || "";
          el.querySelector(".action").textContent = d.action || "";
          el.querySelector(".mainArea").textContent = d.mainArea || "";
          el.querySelector(".areas").textContent = (d.areas || []).join(", ");
          el.querySelector(".descTitle").style.display = d.desc
            ? "block"
            : "none";
          el.querySelector(".desc").textContent = d.desc || "";
          const tagsEl = el.querySelector(".tags");
          tagsEl.innerHTML = (d.tags || [])
            .map((t) => `<span class="badge">${esc(t)}</span>`)
            .join("");
          const linksEl = el.querySelector(".links");
          linksEl.innerHTML = (d.links || [])
            .map((raw) => {
              const url = normalizeURL(raw);
              return url
                ? `<a href="${esc(url)}" target="_blank" rel="noopener">${esc(
                    raw
                  )}</a>`
                : `<span class="muted">${esc(raw)}</span>`;
            })
            .join("");
          const imagesEl = el.querySelector(".images");
          const imgs = (d.files || []).filter((f) => f.isImage && f.url);
          imagesEl.innerHTML = imgs
            .map(
              (f) =>
                `<img src="${esc(f.url)}" alt="${esc(
                  f.name
                )}" draggable="false">`
            )
            .join("");
          const attEl = el.querySelector(".attachments");
          const docs = (d.files || []).filter((f) => !f.isImage && f.url);
          attEl.innerHTML = docs
            .map((f) => {
              const href = esc(f.url),
                name = esc(f.name);
              return f.isPDF
                ? `<a href="${href}" target="_blank" rel="noopener">${name}</a>`
                : `<a href="${href}" download="${name}">${name}</a>`;
            })
            .join(" ");
        }

        /* ======== Edge model / drawing (dirty) ======== */
        function rebuildEdgesIndex() {
          state.edgesByNode.clear();
          state.edges.forEach((e, i) => {
            if (!state.edgesByNode.has(e.s))
              state.edgesByNode.set(e.s, new Set());
            if (!state.edgesByNode.has(e.t))
              state.edgesByNode.set(e.t, new Set());
            state.edgesByNode.get(e.s).add(i);
            state.edgesByNode.get(e.t).add(i);
          });
        }
        function invalidateEdgesForNode(nodeId) {
          const set = state.edgesByNode.get(nodeId);
          if (!set) {
            requestFullEdgeRedraw();
            return;
          }
          for (const idx of set) state.dirtyEdgeIdx.add(idx);
          scheduleRender();
        }
        function requestFullEdgeRedraw() {
          state.needFullEdgeRedraw = true;
        }

        function anchor(id, side) {
          const n = getNodeById(id);
          if (!n) return { x: 0, y: 0 };
          const x = side === "right" ? n.x + (n.w || NODE_W) : n.x;
          const y = n.y + (n.h || NODE_H) / 2;
          return { x, y };
        }
        function pathCubic(a, b) {
          const dx = Math.max(40, Math.abs(b.x - a.x) * 0.5);
          return `M ${a.x} ${a.y} C ${a.x + dx} ${a.y}, ${b.x - dx} ${b.y}, ${
            b.x
          } ${b.y}`;
        }

        function renderEdgesFull() {
          edgeLayer.innerHTML = "";
          state.edgeGroups.length = 0;
          state.edges.forEach((e, i) => {
            const s = anchor(e.s, "right"),
              t = anchor(e.t, "left");
            if (!s || !t) return;
            const g = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            g.dataset.eid = String(i);
            const pv = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            pv.setAttribute("d", pathCubic(s, t));
            pv.setAttribute(
              "class",
              "edge-visible" + (e.dashed ? " weak" : "")
            );
            if (state.selEdges.has(i)) pv.classList.add("selected");
            const ph = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            ph.setAttribute("d", pathCubic(s, t));
            ph.setAttribute("class", "edge-hit");
            g.appendChild(ph);
            g.appendChild(pv);
            edgeLayer.appendChild(g);
            state.edgeGroups[i] = g;
          });
          drawGhostEdges();
        }
        function updateEdgesPartial(idxs) {
          for (const i of idxs) {
            const e = state.edges[i];
            const g = state.edgeGroups[i];
            if (!e || !g) continue;
            const s = anchor(e.s, "right"),
              t = anchor(e.t, "left");
            if (!s || !t) continue;
            const d = pathCubic(s, t);
            const pv = g.querySelector(".edge-visible");
            const ph = g.querySelector(".edge-hit");
            if (pv) pv.setAttribute("d", d);
            if (ph) ph.setAttribute("d", d);
          }
          drawGhostEdges();
        }
        function drawGhostEdges() {
          ghostLayer.innerHTML = "";
          if (!(state.dragLink && state.dragLink.active)) return;
          const t = { x: state.dragLink.x, y: state.dragLink.y };
          for (const sid of state.dragLink.sources) {
            const fromAnchor =
              state.dragLink.from === "out"
                ? anchor(sid, "right")
                : anchor(sid, "left");
            const a = state.dragLink.from === "out" ? fromAnchor : t;
            const b = state.dragLink.from === "out" ? t : fromAnchor;
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            path.setAttribute("d", pathCubic(a, b));
            path.setAttribute("stroke", "#fff");
            path.setAttribute("stroke-width", "2");
            path.setAttribute("fill", "none");
            ghostLayer.appendChild(path);
          }
        }
        function applyEdgeSelection() {
          state.edgeGroups.forEach((g, i) => {
            const pv = g?.querySelector(".edge-visible");
            if (!pv) return;
            pv.classList.toggle("selected", state.selEdges.has(i));
            const e = state.edges[i];
            if (e) pv.classList.toggle("weak", !!e.dashed);
          });
        }

        // Single delegated click for edges (select / Alt+split)
        edgesSVG.addEventListener("click", (ev) => {
          const g = ev.target.closest("g[data-eid]");
          if (!g) return;
          const i = Number(g.dataset.eid);
          if (Number.isNaN(i)) return;
          ev.stopPropagation();
          if (ev.altKey) {
            pushHistory();
            const e = state.edges[i];
            if (!e) return;
            const s = anchor(e.s, "right"),
              t = anchor(e.t, "left"); // midpoint for new node
            const mid = { x: (s.x + t.x) / 2, y: (s.y + t.y) / 2 };
            const nid = addNodeAt(mid.x - NODE_W / 2, mid.y - NODE_H / 2, {});
            const dashed = !!e.dashed;
            state.edges.splice(i, 1);
            state.edges.splice(
              i,
              0,
              { s: e.s, t: nid, dashed },
              { s: nid, t: e.t, dashed }
            );
            rebuildEdgesIndex();
            requestFullEdgeRedraw();
            scheduleRender();
            return;
          }
          if (ev.shiftKey) toggleEdgeSelection(i);
          else selectOnlyEdges([i]);
        });

        /* ======== rAF render loop ======== */
        function scheduleRender() {
          if (!state.rafPending) {
            state.rafPending = true;
            requestAnimationFrame(renderFrame);
          }
        }
        function renderFrame() {
          state.rafPending = false;
          ensureSVGSize();
          updateGrid();

          // Update node transforms (pan/zoom)
          for (const n of state.nodes) positionNode(n);

          if (state.needFullEdgeRedraw) {
            renderEdgesFull();
            state.needFullEdgeRedraw = false;
            state.dirtyEdgeIdx.clear();
          } else if (state.dirtyEdgeIdx.size) {
            updateEdgesPartial(state.dirtyEdgeIdx);
            state.dirtyEdgeIdx.clear();
          } else {
            // still update ghost if active (cursor moved without node movement)
            drawGhostEdges();
          }
        }

        /* ======== Sidebar bindings (live) ======== */
        function fillFormForNode(node) {
          const d = node?.data || emptyData();
          f.date.value = d.date || "";
          f.title.value = d.title || "";
          f.object.value = d.object || "";
          f.action.value = d.action || "";
          f.main.value = d.mainArea || "";
          f.areas.value = (d.areas || []).join(", ");
          f.tags.value = (d.tags || []).join(", ");
          f.desc.value = d.desc || "";
          f.links.value = (d.links || []).join("\n");
          renderFilesList(node);
          f.files.value = "";
        }
        function clearForm() {
          for (const el of [
            f.date,
            f.title,
            f.object,
            f.action,
            f.main,
            f.areas,
            f.tags,
            f.desc,
            f.links,
          ])
            el.value = "";
          f.filesList.innerHTML = "";
        }
        function renderFilesList(node) {
          const files = node?.data?.files || [];
          if (!files.length) {
            f.filesList.innerHTML = "";
            return;
          }
          f.filesList.innerHTML = files
            .map((file, i) => {
              const name = esc(file.name || "file");
              const size = bytes(file.size || 0);
              const thumb =
                file.isImage && file.url
                  ? `<img class="thumb" src="${esc(file.url)}" alt="">`
                  : "";
              return `<div class="file-row">
              <div class="file-left">${thumb}<div class="name">• ${name}${
                size ? " — " + esc(size) : ""
              }</div></div>
              <div class="remove" data-idx="${i}">Remove</div>
            </div>`;
            })
            .join("");
        }
        function fileListToEntries(list) {
          return Array.from(list || []).map((fl) => {
            const isImage = /^image\//i.test(fl.type);
            const isPDF =
              /pdf$/i.test(fl.type) || /\.pdf$/i.test(fl.name || "");
            const url = URL.createObjectURL(fl);
            return {
              name: fl.name,
              size: fl.size,
              type: fl.type,
              url,
              isImage,
              isPDF,
            };
          });
        }
        function updateSidebarSelectionLabel() {
          const n = state.selNodes.size,
            e = state.selEdges.size;
          if (n === 0 && e === 0) {
            f.selInfo.textContent = "No selection";
            return;
          }
          if (n === 1 && e === 0) {
            const id = [...state.selNodes][0];
            const node = getNodeById(id);
            f.selInfo.textContent = `Selected: ${node?.data?.title || id}`;
            return;
          }
          if (n === 0 && e === 1) {
            const i = [...state.selEdges][0];
            const ed = getEdgeByIndex(i);
            f.selInfo.textContent = `Selected edge: ${ed?.s || "?"} → ${
              ed?.t || "?"
            }`;
            return;
          }
          f.selInfo.textContent = `${n} node(s), ${e} edge(s) selected`;
        }
        function refreshSidebarForms() {
          const showNode =
            state.selNodes.size === 1 && state.selEdges.size === 0;
          const showEdge =
            state.selEdges.size === 1 && state.selNodes.size === 0;
          f.nodeForm.style.display = showNode ? "block" : "none";
          f.edgeForm.style.display = showEdge ? "block" : "none";
          f.panelTitle.textContent = showEdge
            ? "Edge properties"
            : "Node properties";
          if (showNode) {
            fillFormForNode(getNodeById([...state.selNodes][0]));
          } else if (!showEdge) {
            clearForm();
          }
          if (showEdge) {
            const idx = [...state.selEdges][0];
            const edge = getEdgeByIndex(idx);
            f.eFrom.textContent = edge?.s || "—";
            f.eTo.textContent = edge?.t || "—";
            f.eDashed.checked = !!edge?.dashed;
          }
        }
        function bindLive() {
          const map = [
            [f.date, (d, v) => (d.date = v || todayYMD())],
            [f.title, (d, v) => (d.title = v)],
            [f.object, (d, v) => (d.object = v.trim())],
            [f.action, (d, v) => (d.action = v.trim())],
            [f.main, (d, v) => (d.mainArea = v.trim())],
            [f.areas, (d, v) => (d.areas = splitList(v))],
            [f.tags, (d, v) => (d.tags = splitList(v))],
            [f.desc, (d, v) => (d.desc = v)],
            [f.links, (d, v) => (d.links = splitList(v))],
          ];
          for (const [el, apply] of map) {
            el.addEventListener("input", () => {
              if (state.selNodes.size !== 1) return;
              const node = getNodeById([...state.selNodes][0]);
              if (!node) return;
              apply(node.data, el.value);
              populate(node);
              measure(node);
              scheduleHistory();
            });
          }
          f.eDashed.addEventListener("change", () => {
            if (!(state.selEdges.size === 1 && state.selNodes.size === 0))
              return;
            pushHistory();
            const idx = [...state.selEdges][0];
            const edge = getEdgeByIndex(idx);
            if (!edge) return;
            edge.dashed = !!f.eDashed.checked;
            requestFullEdgeRedraw();
            scheduleRender();
          });
          f.btnChoose.addEventListener("click", () => f.files.click());
          f.files.addEventListener("change", () => {
            if (state.selNodes.size !== 1) return;
            pushHistory();
            const node = getNodeById([...state.selNodes][0]);
            node.data.files = (node.data.files || []).concat(
              fileListToEntries(f.files.files)
            );
            f.files.value = "";
            renderFilesList(node);
            populate(node);
            measure(node);
            scheduleHistory();
          });
          f.filesList.addEventListener("click", (e) => {
            const rm = e.target.closest(".remove");
            if (!rm) return;
            const idx = Number(rm.getAttribute("data-idx"));
            if (state.selNodes.size !== 1) return;
            pushHistory();
            const node = getNodeById([...state.selNodes][0]);
            node.data.files.splice(idx, 1);
            renderFilesList(node);
            populate(node);
            measure(node);
            scheduleHistory();
          });
          $("#btnUndo").addEventListener("click", undo);
          $("#btnRedo").addEventListener("click", redo);
        }
        bindLive();

        /* ======== Selection helpers ======== */
        function refreshNodeSelectionClasses() {
          document.querySelectorAll(".node").forEach((el) => {
            state.selNodes.has(el.id)
              ? el.classList.add("selected")
              : el.classList.remove("selected");
          });
        }
        function selectOnlyNodes(ids) {
          state.selNodes = new Set(ids);
          state.selEdges.clear();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          if (ids.length === 1) fillFormForNode(getNodeById(ids[0]));
          else clearForm();
        }
        function toggleNodeSelection(id) {
          if (state.selNodes.has(id)) state.selNodes.delete(id);
          else state.selNodes.add(id);
          refreshNodeSelectionClasses();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
        }
        function selectOnlyEdges(indexes) {
          state.selEdges = new Set(indexes);
          state.selNodes.clear();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          clearForm();
        }
        function toggleEdgeSelection(index) {
          if (state.selEdges.has(index)) state.selEdges.delete(index);
          else state.selEdges.add(index);
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
        }
        function clearEdgeSelection() {
          state.selEdges.clear();
          applyEdgeSelection();
        }
        function clearAllSelection() {
          state.selNodes.clear();
          state.selEdges.clear();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          clearForm();
        }
        function selectAll() {
          state.selNodes = new Set(state.nodes.map((n) => n.id));
          state.selEdges = new Set(state.edges.map((_, i) => i));
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
        }

        /* ======== Toolbar ======== */
        $("#btnAdd").addEventListener("click", addNode);
        $("#btnDel").addEventListener("click", doDeleteSelection);
        $("#btnFit").addEventListener("click", fitView);
        $("#btnAuto").addEventListener("click", autoLayoutLeftToRight);
        $("#btnOpen").addEventListener("click", openProject);
        $("#btnSave").addEventListener("click", saveProjectSmart);

        /* ======== Pan / Marquee / Zoom (global) ======== */
        let panning = false,
          startPan = { x: 0, y: 0 };
        stage.addEventListener("mousedown", (e) => {
          if (e.target.closest("g[data-eid]")) return; // edges handled by SVG
          if (e.target !== stage && e.target !== edgesSVG) return;
          if (state.spaceDown) {
            panning = true;
            stage.style.cursor = "move";
            const r = stage.getBoundingClientRect();
            startPan = {
              x: e.clientX - r.left - state.pan.x,
              y: e.clientY - r.top - state.pan.y,
            };
          } else {
            startMarquee(e);
          }
        });
        document.addEventListener("mousemove", onDocMove);
        document.addEventListener("mouseup", onDocUp);

        stage.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const sensitivity = 0.012;
            const d = -e.deltaY * sensitivity;
            const old = state.zoom;
            const z = Math.min(3, Math.max(0.25, old * (1 + d)));
            const r = stage.getBoundingClientRect();
            const mx = e.clientX - r.left,
              my = e.clientY - r.top;
            const wx = (mx - state.pan.x) / old,
              wy = (my - state.pan.y) / old;
            state.zoom = z;
            state.pan.x = mx - wx * z;
            state.pan.y = my - wy * z;
            scheduleRender();
          },
          { passive: false }
        );

        function onDocMove(e) {
          // Pan
          if (panning) {
            const r = stage.getBoundingClientRect();
            state.pan.x = e.clientX - r.left - startPan.x;
            state.pan.y = e.clientY - r.top - startPan.y;
            scheduleRender();
            return;
          }
          // Node drag
          if (state.activeDrag) {
            const cur = toWorld(e.clientX, e.clientY);
            for (const id of state.activeDrag.ids) {
              const n = getNodeById(id);
              if (!n) continue;
              const off = state.activeDrag.offsets[id];
              n.x = cur.x + off.dx;
              n.y = cur.y + off.dy;
              positionNode(n);
              invalidateEdgesForNode(n.id);
            }
            scheduleRender();
          }
          // Edge ghost start / update
          if (state.press) {
            const dx = e.clientX - state.press.startX,
              dy = e.clientY - state.press.startY;
            if (!state.press.moved && Math.hypot(dx, dy) > CLICK_THRESHOLD) {
              state.press.moved = true;
              startGhost(
                state.press.side,
                state.press.sources,
                state.press.primary
              );
            }
          }
          if (state.dragLink && state.dragLink.active) {
            const w = toWorld(e.clientX, e.clientY);
            state.dragLink.x = w.x;
            state.dragLink.y = w.y;
            scheduleRender();
          }
          // Marquee
          if (state.marquee?.active) {
            updateMarquee(e);
          }
        }
        function onDocUp(e) {
          if (panning) {
            panning = false;
            stage.style.cursor = "";
          }
          // Finish node drag
          if (state.activeDrag) {
            for (const id of state.activeDrag.ids) {
              const n = getNodeById(id);
              n && measure(n);
            }
            document
              .querySelectorAll(".node.dragging")
              .forEach((el) => el.classList.remove("dragging"));
            state.activeDrag = null;
          }
          // Handle ghost click/drag resolution uses handle-up on target handles:
          // If user simply released in empty canvas with ghost active → keep ghost until click on compatible handle;
          // If click (no move) on handles resolves edges, that logic is in handleUp (below via stage click)
          if (state.marquee?.active) {
            endMarquee();
          }

          // Reset cursors if not ghosting
          if (!(state.dragLink && state.dragLink.active)) {
            document.body.style.cursor = "";
            stage.style.cursor = "";
          }
        }

        // Ghost helpers
        function startGhost(from, sources, primary) {
          state.dragLink = {
            active: true,
            from,
            sources: [...new Set(sources)],
            primary,
            x: 0,
            y: 0,
          };
          document.body.style.cursor = "grabbing";
          stage.style.cursor = "grabbing";
          setStatus(from === "out" ? "Drag to input…" : "Drag to output…");
        }
        function cancelGhost() {
          state.dragLink = null;
          state.press = null;
          document.body.style.cursor = "";
          stage.style.cursor = "";
          setStatus("");
          scheduleRender();
        }

        // Handle-up logic on handles (click vs ghost connect) via capturing mouseup on the document target
        stage.addEventListener("mouseup", (e) => {
          const handle = e.target.closest(".handle");
          if (!handle) return;
          const side = handle.classList.contains("out") ? "out" : "in";
          const nodeId = handle.closest(".node")?.id;
          if (!nodeId) return;

          // Ghost connect if compatible
          if (state.dragLink && state.dragLink.active) {
            const from = state.dragLink.from;
            if (
              (from === "out" && side === "in") ||
              (from === "in" && side === "out")
            ) {
              pushHistory();
              if (from === "out") {
                for (const s of state.dragLink.sources) {
                  if (s !== nodeId) addEdge(s, nodeId);
                }
              } else {
                for (const t of state.dragLink.sources) {
                  if (t !== nodeId) addEdge(nodeId, t);
                }
              }
              cancelGhost();
              rebuildEdgesIndex();
              requestFullEdgeRedraw();
              scheduleRender();
              setStatus("Edge created");
              return;
            }
          }
          // Click (no ghost) on OUT → create child(ren)
          if (state.press && !state.press.moved && state.press.side === side) {
            if (side === "out" && !state.dragLink) {
              pushHistory();
              const srcs = state.press.sources;
              for (const sid of srcs) {
                const parent = getNodeById(sid);
                if (!parent) continue;
                const pos = nextChildPosition(parent);
                const p = parent.data;
                const init = {
                  object: p.object,
                  action: p.action,
                  mainArea: p.mainArea,
                  areas: [...p.areas],
                };
                const childId = addNodeAt(pos.x, pos.y, init);
                addEdge(parent.id, childId);
              }
              rebuildEdgesIndex();
              requestFullEdgeRedraw();
              scheduleRender();
              setStatus(
                srcs.length > 1
                  ? "Children created and connected"
                  : "Child created and connected"
              );
            }
          }
          state.press = null;
        });

        // Stage click: cancel ghost OR deselect (ignore click right after marquee)
        stage.addEventListener("click", (e) => {
          if (state.ignoreNextStageClick) {
            state.ignoreNextStageClick = false;
            return;
          }
          if (e.target === stage || e.target === edgesSVG) {
            if (state.dragLink) {
              cancelGhost();
            } else {
              clearAllSelection();
            }
          }
        });

        // ESC
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            if (state.dragLink) {
              cancelGhost();
            } else {
              clearAllSelection();
            }
          }
        });

        /* ======== Keyboard shortcuts ======== */
        document.addEventListener("keydown", (e) => {
          const tag = document.activeElement?.tagName;
          const inText =
            tag === "INPUT" ||
            tag === "TEXTAREA" ||
            document.activeElement?.isContentEditable;

          if (e.code === "Space") {
            state.spaceDown = true;
            e.preventDefault();
            stage.style.cursor = "move";
            return;
          }

          if ((e.metaKey || e.ctrlKey) && !inText) {
            const k = e.key.toLowerCase();
            if (k === "z" && !e.shiftKey) {
              e.preventDefault();
              undo();
              return;
            }
            if ((k === "z" && e.shiftKey) || k === "y") {
              e.preventDefault();
              redo();
              return;
            }
            if (k === "o") {
              e.preventDefault();
              openProject();
              return;
            }
            if (k === "s" && !e.shiftKey) {
              e.preventDefault();
              saveProjectSmart();
              return;
            }
            if (k === "s" && e.shiftKey) {
              e.preventDefault();
              saveAs();
              return;
            }
            if (k === "p") {
              e.preventDefault();
              exportJSON();
              return;
            }
            if (k === "n") {
              e.preventDefault();
              newProject();
              return;
            }
            if (k === "a" && !e.shiftKey) {
              e.preventDefault();
              selectAll();
              return;
            }
            if (k === "a" && e.shiftKey) {
              e.preventDefault();
              clearAllSelection();
              return;
            }
            if (k === "d" && !e.shiftKey) {
              e.preventDefault();
              duplicateSelection();
              return;
            }
          }
          if ((e.key === "Delete" || e.key === "Backspace") && !inText) {
            e.preventDefault();
            doDeleteSelection();
            return;
          }
          if (e.key === "0") {
            e.preventDefault();
            fitView();
            return;
          }
          if ((e.key === "l" || e.key === "L") && !inText) {
            if (state.selNodes.size === 2) {
              pushHistory();
              const [a, b] = [...state.selNodes];
              const na = getNodeById(a),
                nb = getNodeById(b);
              if (na && nb) {
                const s = na.x <= nb.x ? a : b;
                const t = na.x <= nb.x ? b : a;
                addEdge(s, t);
                rebuildEdgesIndex();
                requestFullEdgeRedraw();
                scheduleRender();
                setStatus(`Connected ${s} → ${t}`);
              }
            }
          }
        });
        document.addEventListener("keyup", (e) => {
          if (e.code === "Space") {
            state.spaceDown = false;
            stage.style.cursor = "";
          }
        });

        function doDeleteSelection() {
          if (state.selEdges.size || state.selNodes.size) pushHistory();
          if (state.selEdges.size) {
            const del = [...state.selEdges].sort((a, b) => b - a);
            del.forEach((i) => state.edges.splice(i, 1));
            state.selEdges.clear();
          }
          if (state.selNodes.size) {
            const ids = [...state.selNodes];
            state.edges = state.edges.filter(
              (e) => !state.selNodes.has(e.s) && !state.selNodes.has(e.t)
            );
            ids.forEach((id) => document.getElementById(id)?.remove());
            state.nodes = state.nodes.filter((n) => !state.selNodes.has(n.id));
            state.selNodes.clear();
          }
          rebuildEdgesIndex();
          requestFullEdgeRedraw();
          scheduleRender();
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          clearForm();
        }

        /* ======== View / layout ======== */
        function applyView() {
          ensureSVGSize();
          updateGrid();
          state.nodes.forEach((n) => positionNode(n));
          scheduleRender();
        }
        function fitView() {
          if (!state.nodes.length) {
            state.zoom = 1;
            state.pan = { x: 0, y: 0 };
            applyView();
            return;
          }
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          for (const n of state.nodes) {
            minX = Math.min(minX, n.x);
            minY = Math.min(minY, n.y);
            maxX = Math.max(maxX, n.x + (n.w || NODE_W));
            maxY = Math.max(maxY, n.y + (n.h || NODE_H));
          }
          const r = stage.getBoundingClientRect(),
            vw = r.width,
            vh = r.height;
          const bw = maxX - minX,
            bh = maxY - minY,
            m = 80;
          const zx = (vw - m) / bw,
            zy = (vh - m) / bh;
          state.zoom = Math.min(3, Math.max(0.25, Math.min(zx, zy)));
          const cx = (minX + maxX) / 2,
            cy = (minY + maxY) / 2;
          state.pan.x = vw / 2 - cx * state.zoom;
          state.pan.y = vh / 2 - cy * state.zoom;
          applyView();
        }

        function startMarquee(e) {
          const rect = document.createElement("div");
          rect.className = "marquee";
          stage.appendChild(rect);
          const r = stage.getBoundingClientRect();
          state.marquee = {
            active: true,
            startX: e.clientX - r.left,
            startY: e.clientY - r.top,
            curX: e.clientX - r.left,
            curY: e.clientY - r.top,
            el: rect,
            additive: e.shiftKey,
          };
          state.ignoreNextStageClick = true;
          drawMarqueeRect();
        }
        function updateMarquee(e) {
          const r = stage.getBoundingClientRect();
          state.marquee.curX = e.clientX - r.left;
          state.marquee.curY = e.clientY - r.top;
          drawMarqueeRect();
          const a = toWorld(
            state.marquee.startX + r.left,
            state.marquee.startY + r.top
          );
          const b = toWorld(
            state.marquee.curX + r.left,
            state.marquee.curY + r.top
          );
          const minX = Math.min(a.x, b.x),
            minY = Math.min(a.y, b.y),
            maxX = Math.max(a.x, b.x),
            maxY = Math.max(a.y, b.y);
          const hitsNodes = new Set(
            state.nodes
              .filter((n) =>
                rectsIntersect(
                  minX,
                  minY,
                  maxX,
                  maxY,
                  n.x,
                  n.y,
                  n.x + (n.w || NODE_W),
                  n.y + (n.h || NODE_H)
                )
              )
              .map((n) => n.id)
          );
          const hitsEdges = new Set(
            state.edges
              .map((e, i) => ({ bb: edgeBBox(e), i }))
              .filter((o) =>
                rectsIntersect(
                  minX,
                  minY,
                  maxX,
                  maxY,
                  o.bb.minX,
                  o.bb.minY,
                  o.bb.maxX,
                  o.bb.maxY
                )
              )
              .map((o) => o.i)
          );
          if (state.marquee.additive) {
            hitsNodes.forEach((id) => state.selNodes.add(id));
            hitsEdges.forEach((i) => state.selEdges.add(i));
          } else {
            state.selNodes = hitsNodes;
            state.selEdges = hitsEdges;
          }
          refreshNodeSelectionClasses();
          applyEdgeSelection();
          updateSidebarSelectionLabel();
          refreshSidebarForms();
          if (state.selNodes.size === 1 && state.selEdges.size === 0)
            fillFormForNode(getNodeById([...state.selNodes][0]));
          else clearForm();
        }
        function endMarquee() {
          state.marquee.el.remove();
          state.marquee = null;
        }
        function drawMarqueeRect() {
          const m = state.marquee;
          if (!m) return;
          const x = Math.min(m.startX, m.curX),
            y = Math.min(m.startY, m.curY),
            w = Math.abs(m.curX - m.startX),
            h = Math.abs(m.curY - m.startY);
          m.el.style.left = x + "px";
          m.el.style.top = y + "px";
          m.el.style.width = w + "px";
          m.el.style.height = h + "px";
        }
        function rectsIntersect(
          aMinX,
          aMinY,
          aMaxX,
          aMaxY,
          bMinX,
          bMinY,
          bMaxX,
          bMaxY
        ) {
          return (
            aMinX <= bMaxX && aMaxX >= bMinX && aMinY <= bMaxY && aMaxY >= bMinY
          );
        }
        function edgeBBox(e) {
          const s = anchor(e.s, "right"),
            t = anchor(e.t, "left");
          const minX = Math.min(s.x, t.x),
            maxX = Math.max(s.x, t.x),
            minY = Math.min(s.y, t.y),
            maxY = Math.max(s.y, t.y);
          return { minX, minY, maxX, maxY };
        }

        /* ======== Auto layout ======== */
        function autoLayoutLeftToRight() {
          pushHistory();
          state.nodes.forEach((n) => measure(n));
          const indeg = new Map(state.nodes.map((n) => [n.id, 0]));
          state.edges.forEach((e) => indeg.set(e.t, (indeg.get(e.t) || 0) + 1));
          const roots = state.nodes
            .filter((n) => (indeg.get(n.id) || 0) === 0)
            .map((n) => n.id);
          const depth = new Map();
          const q = [...roots];
          roots.forEach((id) => depth.set(id, 0));
          while (q.length) {
            const u = q.shift();
            const d = depth.get(u) || 0;
            state.edges
              .filter((e) => e.s === u)
              .forEach((e) => {
                if (!depth.has(e.t)) {
                  depth.set(e.t, d + 1);
                  q.push(e.t);
                }
              });
          }
          state.nodes.forEach((n) => {
            if (!depth.has(n.id)) depth.set(n.id, 0);
          });
          const layers = {};
          state.nodes.forEach((n) => {
            const d = depth.get(n.id) || 0;
            (layers[d] ||= []).push(n);
          });
          const layerKeys = Object.keys(layers)
            .map(Number)
            .sort((a, b) => a - b);
          let x = 0;
          layerKeys.forEach((li) => {
            const col = layers[li];
            col.sort((a, b) => a.y - b.y);
            let y = 0;
            for (const n of col) {
              n.x = x;
              n.y = y;
              const h = n.h || NODE_H;
              y += h + Math.max(VGAP, MIN_LAYER_GAP);
            }
            x += NODE_W + HGAP;
          });
          state.nodes.forEach((n) => positionNode(n));
          rebuildEdgesIndex();
          requestFullEdgeRedraw();
          scheduleRender();
          setStatus("Auto layout applied");
        }
        function nextChildPosition(parent) {
          const children = state.edges
            .filter((e) => e.s === parent.id)
            .map((e) => getNodeById(e.t))
            .filter(Boolean);
          const baseX = parent.x + (parent.w || NODE_W) + HGAP;
          if (children.length === 0) return { x: baseX, y: parent.y };
          const last = children.reduce(
            (a, c) => (c.y > a.y ? c : a),
            children[0]
          );
          return { x: baseX, y: last.y + (last.h || NODE_H) + VGAP };
        }

        function addEdge(s, t) {
          if (!s || !t || s === t) return;
          if (state.edges.some((e) => e.s === s && e.t === t)) return;
          state.edges.push({ s, t, dashed: false });
          rebuildEdgesIndex();
          requestFullEdgeRedraw();
          scheduleRender();
        }

        /* ======== SAVE / OPEN (unchanged behavior) ======== */
        async function saveProjectSmart() {
          if (projectCtx.mode === "folder" && projectCtx.dirHandle) {
            await saveProjectToDir(projectCtx.dirHandle);
            setStatus("Project saved");
            return;
          }
          await saveAs();
        }
        async function saveAs() {
          const supportsFS = "showDirectoryPicker" in window;
          if (supportsFS) {
            try {
              const dir = await window.showDirectoryPicker({
                mode: "readwrite",
              });
              await saveProjectToDir(dir);
              projectCtx.mode = "folder";
              projectCtx.dirHandle = dir;
              setStatus("Project saved (new location)");
              return;
            } catch (err) {
              console.warn(
                "Save As cancelled or failed, falling back to download",
                err
              );
            }
          }
          await saveCopy();
          projectCtx.mode = "embedded";
          projectCtx.dirHandle = null;
        }
        async function saveProjectToDir(dir) {
          await ensureSubdir(dir, "assets");
          const used = new Map();
          const uniq = (name) => {
            const clean = sanitizeName(
              (name || "file").replace(
                /\.(png|jpg|jpeg|webp|gif|heic|heif|bmp|tiff)$/i,
                ""
              )
            );
            let n = clean,
              i = 1;
            while (used.has(n.toLowerCase())) n = `${clean}_${i++}`;
            used.set(n.toLowerCase(), true);
            return n;
          };
          const project = {
            version: 5,
            nodes: [],
            edges: state.edges.map((e) => ({
              s: e.s,
              t: e.t,
              dashed: !!e.dashed,
            })),
          };
          for (const n of state.nodes) {
            const nodeClone = {
              id: n.id,
              x: n.x,
              y: n.y,
              w: n.w,
              h: n.h,
              group: n.group || null,
              data: { ...n.data, files: [] },
            };
            for (const f of n.data.files || []) {
              let blob = await fetch(f.url).then((r) => r.blob());
              let ext = "";
              if (/^image\//i.test(f.type) || f.isImage) {
                blob = await resizeImageBlob(
                  blob,
                  IMG_MAX_SIDE,
                  IMG_TARGET_BYTES
                );
                ext = ".jpg";
              } else if (f.isPDF) {
                ext = ".pdf";
              } else {
                const m = (f.name || "").match(/\.[a-z0-9]+$/i);
                ext = m ? m[0] : ".bin";
              }
              const base = uniq(f.name || "file");
              const rel = `assets/${base}${ext}`;
              await writeFileByPath(dir, rel, blob);
              nodeClone.data.files.push({
                name: `${base}${ext}`,
                size: blob.size,
                type: blob.type || (f.isImage ? "image/jpeg" : f.type),
                isImage: !!(f.isImage || /^image\//i.test(f.type)),
                isPDF: !!f.isPDF,
                path: rel,
              });
            }
            project.nodes.push(nodeClone);
          }
          const jsonBlob = new Blob([JSON.stringify(project, null, 2)], {
            type: "application/json",
          });
          await writeFileByPath(dir, "project.json", jsonBlob);
        }
        async function saveCopy() {
          const embedded = {
            version: 5,
            nodes: await Promise.all(
              state.nodes.map(async (n) => {
                const files = await Promise.all(
                  (n.data.files || []).map(async (f) => {
                    let blob = await fetch(f.url).then((r) => r.blob());
                    if (/^image\//i.test(f.type) || f.isImage)
                      blob = await resizeImageBlob(
                        blob,
                        IMG_MAX_SIDE,
                        IMG_TARGET_BYTES
                      );
                    const dataUrl = await blobToDataURL(blob);
                    return {
                      name: f.name,
                      size: blob.size,
                      type: blob.type,
                      isImage: !!(f.isImage || /^image\//i.test(f.type)),
                      isPDF: !!f.isPDF,
                      dataUrl,
                    };
                  })
                );
                return {
                  id: n.id,
                  x: n.x,
                  y: n.y,
                  w: n.w,
                  h: n.h,
                  group: n.group || null,
                  data: { ...n.data, files },
                };
              })
            ),
            edges: state.edges.map((e) => ({
              s: e.s,
              t: e.t,
              dashed: !!e.dashed,
            })),
          };
          const blob = new Blob([JSON.stringify(embedded, null, 2)], {
            type: "application/json",
          });
          downloadBlob("project.json", blob);
          setStatus("Project JSON downloaded (images resized)");
        }
        async function openProject() {
          const supportsFS = "showDirectoryPicker" in window;
          if (supportsFS) {
            try {
              const dir = await window.showDirectoryPicker({
                mode: "readwrite",
              });
              let fileHandle;
              try {
                fileHandle = await dir.getFileHandle("project.json", {
                  create: false,
                });
              } catch {
                setStatus("project.json not found in selected folder");
                return;
              }
              const file = await fileHandle.getFile();
              const project = JSON.parse(await file.text());
              pushHistory();
              await loadProject(project, dir);
              projectCtx.mode = "folder";
              projectCtx.dirHandle = dir;
              setStatus("Project opened from folder");
              return;
            } catch (err) {
              console.warn("FS open error, falling back to JSON input", err);
            }
          }
          f.openFile.onchange = async () => {
            const fl = f.openFile.files?.[0];
            if (!fl) return;
            const text = await fl.text();
            const project = JSON.parse(text);
            pushHistory();
            await loadProject(project, null);
            projectCtx.mode = "embedded";
            projectCtx.dirHandle = null;
            setStatus("Project opened from JSON file");
            f.openFile.value = "";
          };
          f.openFile.click();
        }
        async function newProject() {
          pushHistory();
          clearAllSelection();
          document.querySelectorAll(".node").forEach((n) => n.remove());
          state.nodes = [];
          state.edges = [];
          state.pan = { x: 0, y: 0 };
          state.zoom = 1;
          projectCtx.mode = null;
          projectCtx.dirHandle = null;
          addNodeAt(80, 80, {});
          setStatus("New project");
        }
        async function loadProject(project, dirHandle) {
          clearAllSelection();
          document.querySelectorAll(".node").forEach((n) => n.remove());
          state.nodes = [];
          state.edges = [];
          for (const pn of project.nodes) {
            const node = {
              id: pn.id || uid(),
              x: pn.x || 0,
              y: pn.y || 0,
              w: pn.w || NODE_W,
              h: pn.h || NODE_H,
              group: pn.group || null,
              data: emptyData(),
            };
            Object.assign(node.data, pn.data || {});
            node.data.files = await Promise.all(
              (pn.data?.files || []).map(async (f) => {
                if (f.dataUrl) {
                  const blob = await (await fetch(f.dataUrl)).blob();
                  return { ...f, url: URL.createObjectURL(blob) };
                } else if (f.path && dirHandle) {
                  const blob = await readFileByPath(dirHandle, f.path);
                  return { ...f, url: URL.createObjectURL(blob) };
                } else {
                  return { ...f, url: "" };
                }
              })
            );
            state.nodes.push(node);
            mountNode(node);
            measure(node);
            positionNode(node);
            populate(node);
          }
          state.edges = (project.edges || []).map((e) => ({
            s: e.s,
            t: e.t,
            dashed: !!e.dashed,
          }));
          ensureSVGSize();
          updateGrid();
          rebuildEdgesIndex();
          requestFullEdgeRedraw();
          scheduleRender();
        }

        /* ======== Clipboard / group (unchanged) ======== */
        function copySelection() {
          if (!state.selNodes.size) return;
          const ids = [...state.selNodes];
          const nodes = ids.map((id) => structuredClone(getNodeById(id)));
          const edges = state.edges
            .filter((e) => ids.includes(e.s) && ids.includes(e.t))
            .map((e) => structuredClone(e));
          const minX = Math.min(...nodes.map((n) => n.x)),
            minY = Math.min(...nodes.map((n) => n.y));
          state.clip = { nodes, edges, dx: minX, dy: minY };
          setStatus("Copied selection");
        }
        function cutSelection() {
          copySelection();
          doDeleteSelection();
          setStatus("Cut selection");
        }
        function pasteClipboard(offset = { x: 40, y: 40 }) {
          if (!state.clip) return;
          pushHistory();
          const idMap = new Map();
          const pastedIds = [];
          for (const src of state.clip.nodes) {
            const id = uid();
            idMap.set(src.id, id);
            const clone = structuredClone(src);
            clone.id = id;
            clone.x = clone.x - state.clip.dx + offset.x;
            clone.y = clone.y - state.clip.dy + offset.y;
            state.nodes.push(clone);
            mountNode(clone);
            measure(clone);
            positionNode(clone);
            populate(clone);
            pastedIds.push(id);
          }
          const newEdges = state.clip.edges.map((e) => ({
            s: idMap.get(e.s),
            t: idMap.get(e.t),
            dashed: !!e.dashed,
          }));
          state.edges.push(...newEdges);
          rebuildEdgesIndex();
          requestFullEdgeRedraw();
          scheduleRender();
          selectOnlyNodes(pastedIds);
          setStatus("Pasted");
        }
        function duplicateSelection() {
          if (!state.selNodes.size) return pasteClipboard({ x: 40, y: 40 });
        }
        function groupSelection() {
          if (!state.selNodes.size) return;
          pushHistory();
          const gid = state.groupSeq || 1;
          state.groupSeq = gid + 1;
          for (const id of state.selNodes) {
            const n = getNodeById(id);
            if (n) n.group = gid;
          }
          setStatus(`Grouped ${state.selNodes.size} node(s)`);
        }
        function ungroupSelection() {
          if (!state.selNodes.size) return;
          pushHistory();
          for (const id of state.selNodes) {
            const n = getNodeById(id);
            if (n) n.group = null;
          }
          setStatus("Ungrouped");
        }

        // Background dblclick → new node
        stage.addEventListener("dblclick", (e) => {
          if (e.target !== stage && e.target !== edgesSVG) return;
          const w = toWorld(e.clientX, e.clientY);
          addNodeAt(w.x, w.y);
        });

        /* ======== FS utils / images ======== */
        async function ensureSubdir(dirHandle, name) {
          try {
            return await dirHandle.getDirectoryHandle(name, { create: true });
          } catch (e) {
            return await dirHandle.getDirectoryHandle(name, { create: false });
          }
        }
        function sanitizeName(name) {
          return (name || "file").replace(/[\\\/:*?"<>|]/g, "_");
        }
        async function writeFileByPath(root, relPath, blob) {
          const parts = relPath.split("/");
          const fileName = parts.pop();
          let dir = root;
          for (const seg of parts) {
            dir = await dir.getDirectoryHandle(seg, { create: true });
          }
          const fh = await dir.getFileHandle(fileName, { create: true });
          const w = await fh.createWritable();
          await w.write(blob);
          await w.close();
        }
        async function readFileByPath(root, relPath) {
          const parts = relPath.split("/");
          const fileName = parts.pop();
          let dir = root;
          for (const seg of parts) {
            dir = await dir.getDirectoryHandle(seg, { create: false });
          }
          const fh = await dir.getFileHandle(fileName, { create: false });
          return await fh.getFile();
        }
        async function resizeImageBlob(
          blob,
          maxSide = 1500,
          targetBytes = 512 * 1024
        ) {
          const img = await blobToImage(blob);
          const { w, h } = fitWithin(
            img.naturalWidth || img.width,
            img.naturalHeight || img.height,
            maxSide
          );
          const canvas =
            "OffscreenCanvas" in window
              ? new OffscreenCanvas(w, h)
              : document.createElement("canvas");
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, w, h);
          let q = 0.92;
          let out = await canvasToBlob(canvas, "image/jpeg", q);
          while (out.size > targetBytes && q > 0.5) {
            q -= 0.08;
            out = await canvasToBlob(canvas, "image/jpeg", q);
          }
          return out;
        }
        function fitWithin(w, h, maxSide) {
          if (w >= h) {
            const s = maxSide / w;
            return { w: Math.round(w * s), h: Math.round(h * s) };
          } else {
            const s = maxSide / h;
            return { w: Math.round(w * s), h: Math.round(h * s) };
          }
        }
        function blobToImage(blob) {
          return new Promise((res, rej) => {
            const url = URL.createObjectURL(blob);
            const img = new Image();
            img.onload = () => {
              URL.revokeObjectURL(url);
              res(img);
            };
            img.onerror = rej;
            img.src = url;
          });
        }
        function canvasToBlob(canvas, type, quality) {
          return new Promise((res) => {
            if (canvas.convertToBlob) {
              canvas.convertToBlob({ type, quality }).then(res);
            } else {
              canvas.toBlob(res, type, quality);
            }
          });
        }
        function blobToDataURL(blob) {
          return new Promise((res) => {
            const r = new FileReader();
            r.onload = () => res(r.result);
            r.readAsDataURL(blob);
          });
        }
        function downloadBlob(filename, blob) {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            URL.revokeObjectURL(a.href);
            a.remove();
          }, 0);
        }

        /* ======== Init ======== */
        pushHistory();
        if (state.nodes.length === 0) {
          addNodeAt(80, 80, {});
        }

        // Edge handle mouseup connection by click (when ghost started from IN → click OUT, etc.)
        // Already handled via stage mouseup above.
      })();
    </script>
  </body>
</html>

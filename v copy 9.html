<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D Visualizer – Text Nodes</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="icon" type="image/png" href="./asset/threadscape/icon.png" />
    <style>
      :root {
        --bg: #0e0e0e;
        --panel: #151515;
        --panel-soft: #161616;
        --ink: #ffffff;
        --muted: #bdbdbd;
        --line: #2a2a2a;
        --btn-hover: rgba(255, 255, 255, 0.08);
        --btn-active: rgba(255, 255, 255, 0.12);
        --field: #1e1e1e;
        --field-hover: #222222;
        --field-focus-ring: rgba(255, 255, 255, 0.18);
      }
      html,
      body,
      #scene {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font: 14px/1.4 system-ui;
      }
      .toolbar { position: fixed; top: 8px; left: 8px; display: flex; gap: 6px; z-index: 10; }
      .toolbar button,
      .toolbar label,
      .toolbar select {
        appearance: none; -webkit-appearance: none;
        background: transparent;
        border: 1px solid var(--line);
        color: var(--ink);
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      .toolbar button:hover, .toolbar label:hover, .toolbar select:hover { background: var(--btn-hover); }
      .toolbar button:active { background: var(--btn-active); transform: translateY(0.5px); }
      .material-symbols-outlined {
        font-family: "Material Symbols Outlined", "Material Icons Outlined", "Material Icons", sans-serif;
        font-variation-settings: "FILL" 0, "wght" 400, "GRAD" 0, "opsz" 24;
        font-feature-settings: "liga";
        -webkit-font-feature-settings: "liga";
        -moz-font-feature-settings: "liga";
        font-size: 18px; line-height: 1; vertical-align: middle; display: inline-block;
        user-select: none;
      }
      .toolbar .spacer { width: 8px; }
      .panel {
        position: fixed;
        left: 8px;
        top: 8px;
        background: var(--panel-soft);
        border: 1px solid rgba(255, 255, 255, 0.06);
        padding: 8px;
        border-radius: 8px;
        max-width: 360px;
        backdrop-filter: blur(2px);
      }
      .panel h3 {
        margin: 0 0 6px 0;
        font-size: 13px;
        color: #bbb;
      }
      .muted {
        color: #aaa;
        font-size: 12px;
      }
      .tooltip { position: fixed; pointer-events: none; background: #111; border: 1px solid #333; color: #eee; padding: 6px 8px; border-radius: 8px; font-size: 12px; max-width: 420px; display: none; box-shadow: 0 10px 24px rgba(0,0,0,0.45); }
      /* Editor laterale */
      .edit-panel {
        position: fixed;
        top: 8px;
        right: 8px;
        width: 360px;
        max-height: calc(100% - 16px);
        overflow: auto;
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        padding: 10px;
        display: none;
        backdrop-filter: blur(2px);
      }
      .edit-panel h3 { margin: 0 0 8px 0; font-size: 13px; color: #bbb; }
      .edit-panel label { display:block; font-size:12px; color:#ddd; margin:10px 0 4px 0; }
      .edit-panel input[type="text"], .edit-panel textarea {
        width: 100%; background: #0f0f0f; color: #eee; border: 1px solid #333;
        border-radius: 6px; padding: 8px 10px; font: inherit;
      }
      .edit-panel textarea { min-height: 220px; resize: vertical; }
      .edit-panel { overflow: auto; overflow-wrap: anywhere; }
      .file-row { display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:12px; padding:6px 0; border-bottom:1px solid #333; }
      .file-left { display:flex; align-items:center; gap:8px; min-width:0; }
      .thumb { width:16px; height:16px; border-radius:3px; border:1px solid #333; object-fit:cover; display:block; }
      .file-row .name { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:220px; }
      .file-row .remove { cursor:pointer; text-decoration:underline; }
      .file-row .remove:hover { color:#fff; }
      .status { position: fixed; left: 8px; bottom: 8px; color: var(--muted); font-size: 12px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.06); padding: 6px 8px; border-radius: 8px; }
    </style>
    <!-- Three prima di TUTTO -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <!-- 3d-force-graph -->
    <script src="https://unpkg.com/3d-force-graph"></script>
    <!-- three-spritetext, ORA dopo THREE -->
    <script src="https://unpkg.com/three-spritetext"></script>
    <script>
      // Fail-safe: se per CDN o cache SpriteText fosse namespaced, prendilo da window
      const SpriteText =
        window.SpriteText || window["three-spritetext"] || null;
      if (!SpriteText) {
        console.warn(
          "SpriteText non disponibile; userò le label standard come fallback."
        );
      }
    </script>
  </head>
  <body>
    <div id="scene"></div>

    <div class="toolbar">
      <button id="btnOpenFolder" title="Apri cartella" data-tip="Apri cartella"><span class="material-symbols-outlined">folder_open</span></button>
      <button id="btnSave" title="Salva" data-tip="Salva"><span class="material-symbols-outlined">save</span></button>
      <button id="btnUndo" title="Undo" data-tip="Undo (⌘/Ctrl+Z)"><span class="material-symbols-outlined">undo</span></button>
      <button id="btnRedo" title="Redo" data-tip="Redo (⇧⌘/Ctrl+Z)"><span class="material-symbols-outlined">redo</span></button>
      <button id="btnConnect" title="Collega (C)" data-tip="Collega (C)"><span class="material-symbols-outlined">link</span></button>
      <button id="btnNewNode" title="Nuovo nodo" data-tip="Nuovo nodo"><span class="material-symbols-outlined">add_circle</span></button>
      <button id="btnSpawn" title="Nuovo collegato" data-tip="Nuovo collegato"><span class="material-symbols-outlined">call_split</span></button>
      <button id="btnDelete" title="Elimina" data-tip="Elimina"><span class="material-symbols-outlined">delete</span></button>
      <span class="spacer"></span>
      <button id="btnFit" data-tip="Fit"><span class="material-symbols-outlined">fit_screen</span></button>
      <button id="btnToggleSize" data-tip="Dimensione testo"><span class="material-symbols-outlined">format_size</span></button>
      <select id="colorBy" title="Colora per…" data-tip="Colori per…">
        <option value="none" selected>Colori: Nessuno</option>
        <option value="area">Colori: per Area</option>
        <option value="cluster">Colori: per Cluster</option>
      </select>
      <label style="display:inline-flex;align-items:center;gap:6px" data-tip="Selezione camera (POV)">
        <input id="chkPOV" type="checkbox" style="accent-color:#888" />
        POV
      </label>
    </div>

    

    <div id="tooltip" class="tooltip"></div>
    <div id="status" class="status" style="display:none"></div>

    <aside id="editor" class="edit-panel">
      <h3>Proprietà nodo</h3>
      <div id="selInfo" class="muted"></div>
      <label for="fTitle">Titolo</label>
      <input id="fTitle" type="text" placeholder="Titolo" />
      <label for="fAreas">Areas (separate da virgola)</label>
      <input id="fAreas" type="text" placeholder="Area1, Area2" />
      <label for="fTags">Tags (separati da virgola)</label>
      <input id="fTags" type="text" placeholder="Tag1, Tag2" />
      <label for="fDesc">Descrizione</label>
      <textarea id="fDesc" placeholder="Descrizione"></textarea>
      <div style="margin-top:10px">
        <button id="btnAddFiles">Aggiungi file…</button>
        <input id="fFiles" type="file" multiple style="display:none" />
      </div>
      <div id="filesList" style="margin-top:6px"></div>
    </aside>

    <script>
      const el = document.getElementById("scene");
      let selectedEdge = null; // edge selezionato (s,t)
      const Graph = ForceGraph3D()(el)
        .backgroundColor("#0c0c0c")
        .nodeRelSize(1) // irrilevante: non usiamo le palline
        .nodeLabel(() => "") // niente balloon label, usiamo sprite+tooltip
        .linkOpacity(0.45)
        .linkWidth((l) => (isEdgeSelected(l) ? 3 : (l.dashed ? 0.6 : 1.4)))
        .linkColor((l) => (isEdgeSelected(l) ? "rgba(255,255,255,0.95)" : (l.dashed ? "rgba(200,200,200,0.35)" : "rgba(220,220,220,0.65)")))
        .nodeColor(() => "#ffffff")
        .linkHoverPrecision(4)
        .enableNodeDrag(true)
        .onNodeHover((node) => {
          // tooltip disattivato: si usa il pannello laterale su click
        })
        .onNodeClick((node, event) => {
          if (!node) return;
          if (event && event.shiftKey) toggleSelection(node.id);
          else selectOnly(node.id);
          // click sul nodo cancella selezione edge
          selectedEdge = null;
          ensureLinkStyleRefresh();
          if (camOnSelect) {
            // camera verso il nodo (3D: usa cameraPosition), movimento morbido
            const distance = 120;
            const nx = node.x || 0, ny = node.y || 0, nz = node.z || 0;
            const len = Math.max(1, Math.hypot(nx, ny, nz));
            const ratio = 1 + distance / len;
            Graph.cameraPosition({ x: nx * ratio, y: ny * ratio, z: nz * ratio }, { x: nx, y: ny, z: nz }, 700);
          }
          lastPinned = node;
        })
        .onLinkClick((link) => {
          if (!link) return;
          const ids = linkIds(link);
          selectedEdge = ids;
          // clear node selection
          selectOnly(null);
          ensureLinkStyleRefresh();
        })
        .onBackgroundClick(() => {
          selectOnly(null);
          selectedEdge = null;
          ensureLinkStyleRefresh();
        });

      let lastPinned = null;
      let textScale = 1.0; // scala globale del testo
      let selectedIds = new Set(); // selezione multipla
      let currentData = { nodes: [], links: [] }; // dati correnti
      const history = { undo: [], redo: [], limit: 50 };

      // —— Helper immagini + cache texture ——
      // Usa l’istanza di THREE disponibile (quella globale esposta anche da 3d-force-graph)
      const THREE = window.THREE;
      // Base per i path relativi (se l'HTML e la cartella "assets/" sono accanto, lascia "./")
      const ASSET_BASE = "./";

      // Risolvi una URL immagine a partire dal campo files.path / dataUrl / url
      function resolveImageURL(raw) {
        if (!raw) return null;
        // data URL, blob URL o http(s)
        if (/^data:|^blob:|^https?:\/\//i.test(raw)) return raw;
        // path relativo (es. "assets/xxx.jpg")
        return ASSET_BASE + String(raw).replace(/^\.?\//, "");
      }

      // Trova la prima immagine nel nodo Threadscape (data.files)
      function pickNodeImageFromFiles(files) {
        if (!Array.isArray(files)) return null;
        for (const f of files) {
          if (f && f.isImage) {
            // priorità al path (salvato da “Save to folder”), poi dataUrl/url
            const candidate = f.path || f.dataUrl || f.url;
            const url = resolveImageURL(candidate);
            if (url) return url;
          }
        }
        return null;
      }

      // Raccogli tutte le immagini disponibili per un nodo (files + fallback image)
      function imageUrlsForNode(node) {
        const out = [];
        const files = Array.isArray(node.files) ? node.files : [];
        for (const f of files) {
          if (f && f.isImage) {
            const candidate = f.url || f.path || f.dataUrl;
            const u = resolveImageURL(candidate);
            if (u) out.push(u);
          }
        }
        if (!out.length) {
          const single = resolveImageURL(node.image || node.img);
          if (single) out.push(single);
        }
        return out;
      }

      // Texture loader con cache
      const __texCache = new Map();
      const texLoader = new THREE.TextureLoader();
      function loadTextureCached(url, onOk, onErr) {
        if (!url) return onErr && onErr();
        if (__texCache.has(url)) return onOk(__texCache.get(url));
        texLoader.load(
          url,
          (tex) => {
            __texCache.set(url, tex);
            onOk(tex);
          },
          undefined,
          (e) => {
            onErr && onErr(e);
          }
        );
      }

      // ————— TEXT + THUMBNAIL NODES —————
      const TEXT_H = 6; // altezza del testo (world units)
      const IMG_H = 14; // altezza thumbnail (world units)
      let colorMode = "none"; // none | area | cluster

      function getNodeColor(node) {
        if (colorMode === "none") return "#ffffff";
        let key = "";
        if (colorMode === "area") key = (Array.isArray(node.areas) && node.areas[0]) || "";
        else if (colorMode === "cluster") key = (node.__cluster ?? "");
        key = String(key || "");
        return key ? groupColor(key) : "#cbd5e1";
      }

      function buildNodeObject(node) {
        const group = new THREE.Group();

        // 1) Etichetta testuale (sempre, colorata in base alla selezione)
        if (SpriteText) {
          const label = new SpriteText(node.name || node.id || "");
          const isSel = selectedIds.has(node.id);
          const baseColor = getNodeColor(node);
          label.color = isSel ? "#000000" : baseColor;
          label.textHeight = TEXT_H * textScale;
          label.backgroundColor = isSel ? "rgba(255,255,255,0.95)" : "rgba(0,0,0,0.5)";
          group.add(label);
        } else {
          // Fallback minimale se SpriteText non c'è
          const dummy = new THREE.Object3D();
          group.add(dummy);
        }

        // 2) Immagini (se presenti): una riga di sprite sotto il titolo
        const urls = imageUrlsForNode(node);
        if (urls.length) {
          const GAP = 2.0;
          const count = Math.min(urls.length, 4); // limita per performance
          const totalW = count * IMG_H + (count - 1) * GAP;
          const startX = -totalW / 2 + IMG_H / 2;
          const rowY = -(TEXT_H * textScale * 1.3);
          const sprites = [];
          for (let i = 0; i < count; i++) {
            const sprite = new THREE.Sprite(
              new THREE.SpriteMaterial({ transparent: true })
            );
            sprite.scale.set(IMG_H, IMG_H, 1);
            sprite.position.set(startX + i * (IMG_H + GAP), rowY, 0);
            sprite.material.depthTest = false;
            sprite.renderOrder = 1;
            group.add(sprite);
            sprites.push(sprite);

            const url = urls[i];
            loadTextureCached(
              url,
              (tex) => {
                sprite.material.map = tex;
                sprite.material.needsUpdate = true;
                const w = tex.image?.width || 1;
                const h = tex.image?.height || 1;
                const r = h / w;
                sprite.scale.set(IMG_H, IMG_H * r, 1);
              },
              () => {
                group.remove(sprite);
              }
            );
          }
        }

        // 3) Hitbox invisibile per facilitare la selezione (bounding box)
        const name = String(node.name || node.id || "");
        const w = Math.max(60, Math.min(260, name.length * (TEXT_H * 1.6)));
        const h = TEXT_H * 2.0 + (urls.length ? IMG_H * 1.6 : 0);
        const plane = new THREE.Mesh(
          new THREE.PlaneGeometry(w, h),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthTest: false })
        );
        plane.position.set(0, (urls.length ? -IMG_H * 0.3 : 0), -0.01);
        group.add(plane);

        return group;
      }

      function refreshNodeRenderer() {
        Graph.nodeThreeObject(buildNodeObject).nodeThreeObjectExtend(true);
      }

      // inizializza renderer nodi
      refreshNodeRenderer();

      // === Selezione e pannello ===
      function $(sel) { return document.querySelector(sel); }
      function selectOnly(id) {
        selectedIds = new Set(id ? [id] : []);
        updateEditor();
        refreshNodeRenderer();
      }
      function toggleSelection(id) {
        if (!id) return;
        if (selectedIds.has(id)) selectedIds.delete(id);
        else selectedIds.add(id);
        updateEditor();
        refreshNodeRenderer();
      }
      function getSingleSelectedId() {
        return selectedIds.size === 1 ? [...selectedIds][0] : null;
      }
      function updateEditor() {
        const panel = document.getElementById("editor");
        const selInfo = document.getElementById("selInfo");
        if (selectedIds.size !== 1) {
          panel.style.display = "none";
          selInfo.textContent = selectedIds.size ? `${selectedIds.size} nodi selezionati` : "";
          return;
        }
        const sid = getSingleSelectedId();
        const n = currentData.nodes.find((x) => x.id === sid);
        if (!n) {
          panel.style.display = "none";
          selInfo.textContent = "";
          return;
        }
        panel.style.display = "block";
        selInfo.textContent = `Selezionato: ${n.name || n.id}`;
        $("#fTitle").value = n.name || "";
        $("#fAreas").value = (n.areas || []).join(", ");
        $("#fTags").value = (n.tags || []).join(", ");
        $("#fDesc").value = n.desc || "";
        renderFilesListFor(n);
      }
      function renderFilesListFor(n) {
        const list = $("#filesList");
        const files = n.files || [];
        if (!files.length) { list.innerHTML = ""; return; }
        list.innerHTML = files.map((file, i) => {
          const name = escapeHtml(file.name || "file");
          const size = file.size ? ` — ${Math.round(file.size/1024)} KB` : "";
          const thumb = file.isImage && file.url ? `<img class=\"thumb\" src=\"${escapeHtml(file.url)}\">` : "";
          return `<div class=\"file-row\"><div class=\"file-left\">${thumb}<div class=\"name\">• ${name}${size}</div></div><div class=\"remove\" data-idx=\"${i}\">Remove</div></div>`;
        }).join("");
      }

      // Calcolo cluster (grappoli) come componenti connesse
      function computeClusters(nodes, links) {
        const idSet = new Set(nodes.map((n) => n.id));
        const adj = new Map();
        for (const id of idSet) adj.set(id, new Set());
        for (const l of links || []) {
          const s = typeof l.source === 'object' ? l.source?.id : l.source;
          const t = typeof l.target === 'object' ? l.target?.id : l.target;
          if (s == null || t == null) continue;
          if (!adj.has(s)) adj.set(s, new Set());
          if (!adj.has(t)) adj.set(t, new Set());
          adj.get(s).add(t);
          adj.get(t).add(s);
        }
        const comp = new Map();
        let c = 0;
        for (const id of idSet) {
          if (comp.has(id)) continue;
          const stack = [id];
          comp.set(id, c);
          while (stack.length) {
            const u = stack.pop();
            for (const v of adj.get(u) || []) {
              if (!comp.has(v)) {
                comp.set(v, c);
                stack.push(v);
              }
            }
          }
          c++;
        }
        return comp; // Map id -> clusterIndex
      }

      // Normalizza i dati: link sempre come id, copia pulita dei campi
      function normalizeData(d) {
        const nodes = (d?.nodes || []).map((n) => ({
          id: n.id,
          name: n.name || "",
          group: n.group || "",
          type: n.type || "",
          areas: Array.isArray(n.areas) ? [...n.areas] : [],
          tags: Array.isArray(n.tags) ? [...n.tags] : [],
          desc: n.desc || "",
          image: n.image || null,
          files: (n.files || []).map((f) => ({
            name: f.name,
            size: f.size,
            isImage: !!f.isImage,
            isPDF: !!f.isPDF,
            path: f.path || null,
            url: f.url || null,
          })),
        }));
        const idSet = new Set(nodes.map((n) => n.id));
        const links = (d?.links || [])
          .map((l) => {
            const s = typeof l.source === "object" ? l.source?.id : l.source;
            const t = typeof l.target === "object" ? l.target?.id : l.target;
            return { source: s, target: t, dashed: !!l.dashed };
          })
          .filter((l) => idSet.has(l.source) && idSet.has(l.target));
        return { nodes, links };
      }

      // Wrapper per impostare i dati e assegnare i cluster (senza mutare currentData)
      function setGraphData(data) {
        const clean = normalizeData(data || { nodes: [], links: [] });
        try {
          const comp = computeClusters(clean.nodes || [], clean.links || []);
          (clean.nodes || []).forEach((n) => {
            n.__cluster = comp.get(n.id) ?? 0;
          });
        } catch (e) {
          (clean.nodes || []).forEach((n) => (n.__cluster = 0));
        }
        Graph.graphData(clean);
        refreshNodeRenderer();
        setTimeout(() => Graph.zoomToFit(600, 60), 300);
        selectedEdge = null;
        ensureLinkStyleRefresh();
      }

      function ensureLinkStyleRefresh() {
        Graph.linkWidth((l) => (isEdgeSelected(l) ? 3 : (l.dashed ? 0.6 : 1.4)))
             .linkColor((l) => (isEdgeSelected(l) ? "rgba(255,255,255,0.95)" : (l.dashed ? "rgba(200,200,200,0.25)" : "rgba(220,220,220,0.45)")));
      }

      // —— Palette colore deterministica (by group) ——
      const PALETTE = [
        "#7aa2f7",
        "#9ece6a",
        "#f7768e",
        "#bb9af7",
        "#e0af68",
        "#2ac3de",
        "#c0caf5",
        "#73daca",
        "#7dcfff",
        "#f6bd60",
        "#ee6c4d",
        "#84a59d",
        "#f28482",
        "#82aaff",
        "#ffd166",
      ];
      function groupColor(g) {
        if (!g) return "#cbd5e1";
        let h = 0;
        for (let i = 0; i < g.length; i++) h = (h * 31 + g.charCodeAt(i)) >>> 0;
        return PALETTE[h % PALETTE.length];
      }

      // —— Tooltip ricco su hover ——
      function showTip(node) {
        const tip = document.getElementById("tooltip");
        if (!node) {
          tip.style.display = "none";
          window.onmousemove = null;
          return;
        }
        const tags = (node.tags || []).join(", ");
        const areas = (node.areas || []).join(", ");
        const fields = [
          node.type ? `<div><b>Type:</b> ${escapeHtml(node.type)}</div>` : "",
          areas ? `<div><b>Areas:</b> ${escapeHtml(areas)}</div>` : "",
          tags ? `<div><b>Tags:</b> ${escapeHtml(tags)}</div>` : "",
          node.group
            ? `<div><b>Group:</b> ${escapeHtml(node.group)}</div>`
            : "",
        ]
          .filter(Boolean)
          .join("");
        const imgHtml =
          node.image || node.img
            ? `<div style="margin-top:6px">
               <img src="${escapeHtml(resolveImageURL(node.image || node.img))}"
                    style="max-width:240px;max-height:160px;display:block;border:1px solid rgba(255,255,255,.2)"/>
             </div>`
            : "";
        tip.innerHTML = `
          <div style="font-weight:700">${escapeHtml(
            node.name || node.id || ""
          )}</div>
          ${fields}
          ${
            node.desc
              ? `<div style="margin-top:8px; white-space:pre-wrap">${escapeHtml(
                  node.desc
                )}</div>`
              : ""
          }
          ${imgHtml}
        `;
        tip.style.display = "block";
        window.onmousemove = (e) => {
          tip.style.left = e.clientX + 12 + "px";
          tip.style.top = e.clientY + 12 + "px";
        };
      }
      function escapeHtml(s) {
        if (!s) return "";
        return ("" + s).replace(
          /[&<>\"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }

      // —— Toolbar actions ——
      document.getElementById("btnFit").onclick = () => {
        Graph.zoomToFit(600, 60);
      };
      document.getElementById("btnToggleSize").onclick = () => {
        textScale = textScale >= 1.6 ? 0.8 : textScale + 0.2;
        refreshNodeRenderer();
      };

      document.getElementById("colorBy").onchange = (e) => {
        colorMode = e.target.value;
        refreshNodeRenderer();
      };

      // Toolbar extra
      document.getElementById("btnNewNode").onclick = () => addNewNode();
      document.getElementById("btnConnect").onclick = () => connectSelectedNodes();
      document.getElementById("btnSpawn").onclick = () => spawnChildFromSelected();
      document.getElementById("btnDelete").onclick = () => deleteSelected();
      document.getElementById("btnUndo").onclick = () => undo();
      document.getElementById("btnRedo").onclick = () => redo();
      document.getElementById("btnOpenFolder").onclick = async () => {
        try { await openProjectFromFolder(); } catch (e) { alert(e.message || e); }
      };
      document.getElementById("btnSave").onclick = async () => {
        try { await saveProjectSmart(); } catch (e) { alert(e.message || e); }
      };
      // POV toggle (default off)
      let camOnSelect = false;
      const chkPOV = document.getElementById('chkPOV');
      if (chkPOV) chkPOV.addEventListener('change', () => { camOnSelect = !!chkPOV.checked; });

      // Rimosso il caricamento rapido di graphdata.json

      // Tooltip su hover per la toolbar
      (function attachToolbarTooltips(){
        const tip = document.getElementById('tooltip');
        const bar = document.querySelector('.toolbar');
        if (!tip || !bar) return;
        function show(text, x, y){ tip.textContent = text; tip.style.display = 'block'; tip.style.left = (x+12)+ 'px'; tip.style.top = (y+12)+'px'; }
        function hide(){ tip.style.display = 'none'; }
        bar.addEventListener('mouseover', (e)=>{
          const el = e.target.closest('button, select, label'); if (!el) return;
          const t = el.getAttribute('data-tip') || el.title || el.textContent.trim(); if (!t) return;
          show(t, e.clientX, e.clientY);
        });
        bar.addEventListener('mousemove', (e)=>{ if (tip.style.display==='block') { tip.style.left=(e.clientX+12)+'px'; tip.style.top=(e.clientY+12)+'px'; } });
        bar.addEventListener('mouseout', (e)=>{ if (!bar.contains(e.relatedTarget)) hide(); });
      })();

      // Rimosso il picker JSON: usa Apri cartella per caricare/salvare

      function isGraphData(d) {
        return (
          d &&
          Array.isArray(d.nodes) &&
          Array.isArray(d.links) &&
          (d.nodes.length === 0 || d.nodes[0].id !== undefined) &&
          (d.links.length === 0 ||
            ("source" in d.links[0] && "target" in d.links[0]))
        );
      }
      function isThreadscape(d) {
        return (
          d && d.version && Array.isArray(d.nodes) && Array.isArray(d.edges)
        );
      }
      function convertProjectToGraphData(project) {
        const nodes = (project.nodes || []).map((n) => {
          const d = n.data || {};
          const image = pickNodeImageFromFiles(d.files);

          return {
            id: n.id,
            name: d.title || n.id,
            // main area / type non usati in questa vista
            group: "",
            type: "",
            areas: d.areas || [],
            tags: d.tags || [],
            desc: d.desc || "",
            image,
            files: (d.files || []).map((f) => ({
              name: f.name,
              size: f.size,
              isImage: !!f.isImage,
              isPDF: !!f.isPDF,
              path: f.path || null,
              url: f.url || (f.path ? resolveImageURL(f.path) : null),
            })),
          };
        });

        const seen = new Set();
        const links = (project.edges || [])
          .map((e) => {
            const s = e.s,
              t = e.t;
            const key = [s, t].sort().join("||"); // nondirezionale + dedup
            if (seen.has(key)) return null;
            seen.add(key);
            return { source: s, target: t, dashed: !!e.dashed };
          })
          .filter(Boolean);

        return { nodes, links };
      }

      // === Undo/redo helper ===
      function uid() { return "n" + Math.random().toString(36).slice(2, 9); }
      function deepClone(x) { return JSON.parse(JSON.stringify(x)); }
      function pushHistory() {
        history.undo.push(deepClone(normalizeData(currentData)));
        if (history.undo.length > history.limit) history.undo.shift();
        history.redo.length = 0;
      }
      function undo() {
        if (!history.undo.length) return;
        history.redo.push(deepClone(normalizeData(currentData)));
        currentData = history.undo.pop();
        setGraphData(currentData);
        selectOnly(null);
      }
      function redo() {
        if (!history.redo.length) return;
        history.undo.push(deepClone(normalizeData(currentData)));
        currentData = history.redo.pop();
        setGraphData(currentData);
        selectOnly(null);
      }

      // === Azioni sui nodi ===
      function spawnChildFromSelected() {
        const sid = getSingleSelectedId();
        if (!sid) return;
        const parent = currentData.nodes.find((n) => n.id === sid);
        if (!parent) return;
        pushHistory();
        const id = uid();
        const child = {
          id,
          name: "Nuovo nodo",
          areas: [...(parent.areas || [])],
          tags: [],
          desc: "",
          files: [],
        };
        currentData.nodes.push(child);
        currentData.links.push({ source: parent.id, target: id });
        setGraphData(currentData);
        selectOnly(id);
      }
      function deleteSelected() {
        if (!selectedIds.size) return;
        pushHistory();
        const del = new Set(selectedIds);
        currentData.nodes = currentData.nodes.filter((n) => !del.has(n.id));
        currentData.links = currentData.links.filter((l) => {
          const s = typeof l.source === 'object' ? l.source?.id : l.source;
          const t = typeof l.target === 'object' ? l.target?.id : l.target;
          return !del.has(s) && !del.has(t);
        });
        setGraphData(currentData);
        selectOnly(null);
      }

      function connectSelectedNodes() {
        if (selectedIds.size !== 2) {
          setStatus('Seleziona 2 nodi');
          return;
        }
        const [a, b] = [...selectedIds];
        if (a === b) return;
        // evita duplicati (nondirezionale)
        const key = (x, y) => [x, y].sort().join('||');
        const existing = new Set((currentData.links || []).map(l => key(
          typeof l.source === 'object' ? l.source?.id : l.source,
          typeof l.target === 'object' ? l.target?.id : l.target
        )));
        const k = key(a, b);
        if (existing.has(k)) { setStatus('Già collegati'); return; }
        pushHistory();
        currentData.links.push({ source: a, target: b });
        setGraphData(currentData);
        setStatus('Nodi collegati');
      }

      function addNewNode() {
        pushHistory();
        const id = uid();
        currentData.nodes.push({ id, name: 'Nuovo nodo', areas: [], tags: [], desc: '', files: [] });
        setGraphData(currentData);
        selectOnly(id);
        setStatus('Nuovo nodo creato');
      }

      // === Editor bindings ===
      document.getElementById('fTitle').addEventListener('input', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        n.name = document.getElementById('fTitle').value.trim();
        syncGraphNodeById(sid);
        refreshNodeRenderer();
      });
      document.getElementById('fAreas').addEventListener('change', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        const raw = document.getElementById('fAreas').value || '';
        n.areas = raw.split(/,\s*/).filter(Boolean);
        syncGraphNodeById(sid);
        refreshNodeRenderer();
      });
      document.getElementById('fTags').addEventListener('change', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        const raw = document.getElementById('fTags').value || '';
        n.tags = raw.split(/,\s*/).filter(Boolean);
        syncGraphNodeById(sid);
      });
      document.getElementById('fDesc').addEventListener('change', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        n.desc = document.getElementById('fDesc').value;
        syncGraphNodeById(sid);
      });

      document.getElementById('btnAddFiles').addEventListener('click', () => document.getElementById('fFiles').click());
      document.getElementById('fFiles').addEventListener('change', () => {
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        const inp = document.getElementById('fFiles');
        const fls = Array.from(inp.files || []);
        n.files = n.files || [];
        for (const f of fls) {
          const entry = { name: f.name, size: f.size, isImage: /^image\//i.test(f.type), isPDF: /pdf$/i.test(f.type) || /\.pdf$/i.test(f.name), path: 'assets/' + f.name, url: URL.createObjectURL(f), __file: f };
          n.files.push(entry);
        }
        const firstImg = (n.files || []).find(x=>x.isImage);
        n.image = firstImg ? firstImg.url : n.image;
        syncGraphNodeById(sid);
        renderFilesListFor(n);
        refreshNodeRenderer();
        inp.value = '';
      });
      document.getElementById('filesList').addEventListener('click', (e) => {
        const rm = e.target.closest('.remove'); if (!rm) return;
        const sid = getSingleSelectedId(); if (!sid) return; const n = currentData.nodes.find(x=>x.id===sid); if (!n) return;
        const idx = Number(rm.getAttribute('data-idx'));
        if (!Number.isFinite(idx)) return;
        n.files.splice(idx, 1);
        const firstImg = (n.files || []).find(x=>x.isImage);
        n.image = firstImg ? (firstImg.url || resolveImageURL(firstImg.path)) : null;
        syncGraphNodeById(sid);
        renderFilesListFor(n);
        refreshNodeRenderer();
      });

      // sincronizza i cambi di currentData sul grafo vivo
      function syncGraphNodeById(id) {
        const gd = Graph.graphData(); if (!gd) return;
        const gn = (gd.nodes || []).find(x => x.id === id); if (!gn) return;
        const src = (currentData.nodes || []).find(x => x.id === id); if (!src) return;
        gn.name = src.name || '';
        gn.areas = Array.isArray(src.areas) ? [...src.areas] : [];
        gn.tags = Array.isArray(src.tags) ? [...src.tags] : [];
        gn.desc = src.desc || '';
        gn.image = src.image || null;
        gn.files = Array.isArray(src.files) ? src.files.map(f => ({...f})) : [];
      }

      // === File System Access: open/save ===
      const projectCtx = { dirHandle: null };
      async function openProjectFromFolder() {
        if (!('showDirectoryPicker' in window)) throw new Error('Il browser non supporta l\'apertura cartelle');
        const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
        const found = await findProjectJson(dir);
        if (!found) throw new Error('project.json non trovato nella cartella selezionata');
        const { root, fileHandle } = found;
        const file = await fileHandle.getFile();
        const text = await file.text();
        const project = JSON.parse(text);
        if (!isThreadscape(project)) throw new Error('project.json non è nel formato Threadscape');
        projectCtx.dirHandle = root;
        pushHistory();
        currentData = normalizeData(convertProjectToGraphData(project));
        await attachObjectURLsFromDir(root, currentData);
        setGraphData(currentData);
        selectOnly(null);
        setStatus('Nodo/i eliminati');
      }

      // Cerca ricorsivamente project.json partendo dalla cartella scelta
      async function findProjectJson(root, depth = 0, maxDepth = 4) {
        if (!root || depth > maxDepth) return null;
        // prova nella root corrente
        try {
          const fh = await root.getFileHandle('project.json', { create: false });
          if (fh) return { root, fileHandle: fh };
        } catch {}
        // altrimenti scansiona sottocartelle
        try {
          for await (const [name, handle] of root.entries()) {
            if (handle.kind === 'directory') {
              const found = await findProjectJson(handle, depth + 1, maxDepth);
              if (found) return found;
            }
          }
        } catch {}
        return null;
      }
      async function attachObjectURLsFromDir(dir, data) {
        for (const n of data.nodes || []) {
          for (const f of n.files || []) {
            if (f.path && !f.url) {
              try { const file = await readFileByPath(dir, f.path); if (file) f.url = URL.createObjectURL(file); } catch {}
            }
          }
          const firstImg = (n.files || []).find(x=>x.isImage);
          if (firstImg && firstImg.url) n.image = firstImg.url;
        }
      }
      async function saveProjectSmart() {
        if (projectCtx.dirHandle) {
          await saveProjectToDir(projectCtx.dirHandle);
          alert('Salvato');
        } else if ('showDirectoryPicker' in window) {
          const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
          projectCtx.dirHandle = dir;
          await saveProjectToDir(dir);
          alert('Salvato in nuova cartella');
        } else {
          const blob = new Blob([JSON.stringify(buildProjectObject(), null, 2)], { type: 'application/json' });
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'project.json'; a.click();
        }
      }
      function buildProjectObject() {
        const nodes = (currentData.nodes || []).map((n) => {
          const files = (n.files || []).map((f) => ({ name: f.name, size: f.size, isImage: !!f.isImage, isPDF: !!f.isPDF, path: f.path || null }));
          // Esporta senza type e mainArea
          return { id: n.id, data: { title: n.name || n.id, type: '', mainArea: null, areas: n.areas || [], tags: n.tags || [], desc: n.desc || '', files } };
        });
        const edges = (currentData.links || []).map((l) => ({ s: (typeof l.source==='object'?l.source?.id:l.source), t: (typeof l.target==='object'?l.target?.id:l.target), dashed: !!l.dashed }));
        return { version: 6, nodes, edges };
      }
      async function writeFileByPath(root, relPath, blob) {
        const parts = relPath.split('/').filter(Boolean);
        let dir = root;
        for (let i = 0; i < parts.length - 1; i++) { dir = await dir.getDirectoryHandle(parts[i], { create: true }); }
        const fileHandle = await dir.getFileHandle(parts[parts.length - 1], { create: true });
        const w = await fileHandle.createWritable(); await w.write(blob); await w.close();
      }
      async function readFileByPath(root, relPath) {
        const parts = relPath.split('/').filter(Boolean);
        let dir = root;
        for (let i = 0; i < parts.length - 1; i++) { dir = await dir.getDirectoryHandle(parts[i], { create: false }); }
        const fileHandle = await dir.getFileHandle(parts[parts.length - 1], { create: false });
        return await fileHandle.getFile();
      }
      async function saveProjectToDir(dir) {
        for (const n of currentData.nodes || []) {
          for (const f of n.files || []) {
            if (f.__file) {
              const rel = f.path || ('assets/' + f.__file.name);
              await writeFileByPath(dir, rel, f.__file);
              f.path = rel;
            }
          }
        }
        const project = buildProjectObject();
        const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
        await writeFileByPath(dir, 'project.json', blob);
      }

      // Shortcut da tastiera (con guardie per i campi di testo)
      window.addEventListener('keydown', (e) => {
        const isMac = navigator.platform.toUpperCase().includes('MAC');
        const mod = isMac ? e.metaKey : e.ctrlKey;
        const t = e.target;
        const tag = (t && t.tagName ? t.tagName : '').toLowerCase();
        const type = (t && t.type ? String(t.type).toLowerCase() : '');
        const isEditable = (t && t.isContentEditable) || tag === 'textarea' || tag === 'input';
        const isTyping = isEditable && !['button','checkbox','radio','file','submit','reset'].includes(type);

        // Lascia all'input i tasti Undo/Redo e Canc/Backspace
        if (isTyping) {
          if (mod && e.key.toLowerCase() === 'z') return; // undo/redo nativo del campo
          if (!mod && (e.key === 'Delete' || e.key === 'Backspace')) return; // non eliminare nodi se sto scrivendo
          if (!mod && e.key.toLowerCase() === 'c') return; // non catturare 'c' mentre scrivo
        }

        if (mod && e.key.toLowerCase() === 'z') { e.preventDefault(); if (e.shiftKey) redo(); else undo(); }
        else if (mod && e.key.toLowerCase() === 's') { e.preventDefault(); saveProjectSmart(); }
        else if (mod && e.key.toLowerCase() === 'o') { e.preventDefault(); openProjectFromFolder(); }
        else if (e.key === 'Delete' || e.key === 'Backspace') {
          if (selectedIds.size) { e.preventDefault(); deleteSelected(); }
          else if (selectedEdge) { e.preventDefault(); deleteSelectedEdge(); }
        }
        else if (!mod && e.key.toLowerCase() === 'c') { e.preventDefault(); connectSelectedNodes(); }
        else if (e.key === 'Escape') {
          if (!isTyping) {
            selectOnly(null); selectedEdge = null; ensureLinkStyleRefresh();
          }
        }
      });

      // === Edge helper ===
      function linkIds(l) {
        const s = typeof l.source === 'object' ? l.source?.id : l.source;
        const t = typeof l.target === 'object' ? l.target?.id : l.target;
        return { s, t };
      }
      function sameUndirected(a, b) {
        return (a.s === b.s && a.t === b.t) || (a.s === b.t && a.t === b.s);
      }
      function isEdgeSelected(l) {
        if (!selectedEdge) return false;
        return sameUndirected(linkIds(l), selectedEdge);
      }
      function deleteSelectedEdge() {
        if (!selectedEdge) return;
        pushHistory();
        currentData.links = (currentData.links || []).filter((l) => !sameUndirected(linkIds(l), selectedEdge));
        selectedEdge = null;
        setGraphData(currentData);
        setStatus('Edge eliminato');
      }

      // === Status helper ===
      function setStatus(msg) {
        const el = document.getElementById('status');
        if (!el) return;
        if (!msg) { el.style.display = 'none'; el.textContent = ''; return; }
        el.textContent = msg;
        el.style.display = 'block';
        clearTimeout(setStatus._t);
        setStatus._t = setTimeout(() => { el.style.display = 'none'; }, 1800);
      }
    </script>
  </body>
</html>
